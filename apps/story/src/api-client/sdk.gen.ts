// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { DeleteMyArcsByIdData, DeleteMyArcsByIdErrors, DeleteMyArcsByIdResponses, DeleteMyBooksByIdData, DeleteMyBooksByIdErrors, DeleteMyBooksByIdResponses, DeleteMyCalendarsByIdData, DeleteMyCalendarsByIdErrors, DeleteMyCalendarsByIdResponses, DeleteMyChaptersByIdData, DeleteMyChaptersByIdErrors, DeleteMyChaptersByIdResponses, DeleteMyCharactersByCharacterIdInventoryByIdData, DeleteMyCharactersByCharacterIdInventoryByIdErrors, DeleteMyCharactersByCharacterIdInventoryByIdResponses, DeleteMyCharactersByIdData, DeleteMyCharactersByIdErrors, DeleteMyCharactersByIdResponses, DeleteMyContextItemsByIdData, DeleteMyContextItemsByIdErrors, DeleteMyContextItemsByIdResponses, DeleteMyFilesByIdData, DeleteMyFilesByIdErrors, DeleteMyFilesByIdResponses, DeleteMyLandmarksByIdData, DeleteMyLandmarksByIdErrors, DeleteMyLandmarksByIdResponses, DeleteMyMapsByIdData, DeleteMyMapsByIdErrors, DeleteMyMapsByIdResponses, DeleteMyMessagesByIdData, DeleteMyMessagesByIdErrors, DeleteMyMessagesByIdResponses, DeleteMyParagraphsByIdData, DeleteMyParagraphsByIdErrors, DeleteMyParagraphsByIdResponses, DeleteMyPathsByIdData, DeleteMyPathsByIdErrors, DeleteMyPathsByIdResponses, DeleteMyPathSegmentsByIdData, DeleteMyPathSegmentsByIdErrors, DeleteMyPathSegmentsByIdResponses, DeleteMyPawnsByIdData, DeleteMyPawnsByIdErrors, DeleteMyPawnsByIdResponses, DeleteMyScenesByIdData, DeleteMyScenesByIdErrors, DeleteMyScenesByIdResponses, DeleteMyStoriesByIdData, DeleteMyStoriesByIdErrors, DeleteMyStoriesByIdResponses, DeleteMyStoriesByStoryIdTagsByTagIdData, DeleteMyStoriesByStoryIdTagsByTagIdErrors, DeleteMyStoriesByStoryIdTagsByTagIdResponses, GetAuthSessionData, GetAuthSessionResponses, GetCalendarsPresetsData, GetCalendarsPresetsErrors, GetCalendarsPresetsResponses, GetHealthData, GetHealthResponses, GetMyArcsByArcIdChaptersData, GetMyArcsByArcIdChaptersErrors, GetMyArcsByArcIdChaptersResponses, GetMyArcsByIdData, GetMyArcsByIdErrors, GetMyArcsByIdResponses, GetMyBooksByBookIdArcsData, GetMyBooksByBookIdArcsErrors, GetMyBooksByBookIdArcsResponses, GetMyBooksByIdData, GetMyBooksByIdErrors, GetMyBooksByIdResponses, GetMyCalendarsByIdData, GetMyCalendarsByIdErrors, GetMyCalendarsByIdResponses, GetMyChaptersByChapterIdScenesData, GetMyChaptersByChapterIdScenesErrors, GetMyChaptersByChapterIdScenesResponses, GetMyChaptersByIdData, GetMyChaptersByIdErrors, GetMyChaptersByIdResponses, GetMyCharactersByCharacterIdInventoryByIdData, GetMyCharactersByCharacterIdInventoryByIdErrors, GetMyCharactersByCharacterIdInventoryByIdResponses, GetMyCharactersByCharacterIdInventoryData, GetMyCharactersByCharacterIdInventoryErrors, GetMyCharactersByCharacterIdInventoryResponses, GetMyCharactersByIdData, GetMyCharactersByIdErrors, GetMyCharactersByIdResponses, GetMyContextItemsByIdData, GetMyContextItemsByIdErrors, GetMyContextItemsByIdResponses, GetMyFilesByIdData, GetMyFilesByIdErrors, GetMyFilesByIdResponses, GetMyFilesData, GetMyFilesErrors, GetMyFilesResponses, GetMyLandmarksByIdData, GetMyLandmarksByIdErrors, GetMyLandmarksByIdResponses, GetMyMapsByIdData, GetMyMapsByIdErrors, GetMyMapsByIdResponses, GetMyMapsByMapIdLandmarksData, GetMyMapsByMapIdLandmarksErrors, GetMyMapsByMapIdLandmarksResponses, GetMyMapsByMapIdPathsData, GetMyMapsByMapIdPathsErrors, GetMyMapsByMapIdPathsResponses, GetMyMapsByMapIdPawnsData, GetMyMapsByMapIdPawnsErrors, GetMyMapsByMapIdPawnsResponses, GetMyMessageRevisionsByRevisionIdParagraphsData, GetMyMessageRevisionsByRevisionIdParagraphsErrors, GetMyMessageRevisionsByRevisionIdParagraphsResponses, GetMyMessagesByIdData, GetMyMessagesByIdErrors, GetMyMessagesByIdResponses, GetMyMessagesByMessageIdRevisionsData, GetMyMessagesByMessageIdRevisionsErrors, GetMyMessagesByMessageIdRevisionsResponses, GetMyParagraphsByIdData, GetMyParagraphsByIdErrors, GetMyParagraphsByIdResponses, GetMyParagraphsByParagraphIdRevisionsData, GetMyParagraphsByParagraphIdRevisionsErrors, GetMyParagraphsByParagraphIdRevisionsResponses, GetMyPathsByIdData, GetMyPathsByIdErrors, GetMyPathsByIdResponses, GetMyPathsByPathIdSegmentsData, GetMyPathsByPathIdSegmentsErrors, GetMyPathsByPathIdSegmentsResponses, GetMyPathSegmentsByIdData, GetMyPathSegmentsByIdErrors, GetMyPathSegmentsByIdResponses, GetMyPawnsByIdData, GetMyPawnsByIdErrors, GetMyPawnsByIdResponses, GetMyScenesByIdData, GetMyScenesByIdErrors, GetMyScenesByIdResponses, GetMyScenesBySceneIdMessagesData, GetMyScenesBySceneIdMessagesErrors, GetMyScenesBySceneIdMessagesResponses, GetMyStoriesByIdData, GetMyStoriesByIdErrors, GetMyStoriesByIdExportData, GetMyStoriesByIdExportErrors, GetMyStoriesByIdExportResponses, GetMyStoriesByIdResponses, GetMyStoriesByStoryIdBooksData, GetMyStoriesByStoryIdBooksErrors, GetMyStoriesByStoryIdBooksResponses, GetMyStoriesByStoryIdCalendarsData, GetMyStoriesByStoryIdCalendarsErrors, GetMyStoriesByStoryIdCalendarsResponses, GetMyStoriesByStoryIdCharactersData, GetMyStoriesByStoryIdCharactersErrors, GetMyStoriesByStoryIdCharactersResponses, GetMyStoriesByStoryIdContextItemsData, GetMyStoriesByStoryIdContextItemsErrors, GetMyStoriesByStoryIdContextItemsResponses, GetMyStoriesByStoryIdMapsData, GetMyStoriesByStoryIdMapsErrors, GetMyStoriesByStoryIdMapsResponses, GetMyStoriesByStoryIdTagsData, GetMyStoriesByStoryIdTagsErrors, GetMyStoriesByStoryIdTagsResponses, GetMyStoriesData, GetMyStoriesErrors, GetMyStoriesResponses, GetStoriesByIdData, GetStoriesByIdErrors, GetStoriesByIdResponses, GetStoriesData, GetStoriesErrors, GetStoriesResponses, GetTagsData, GetTagsResponses, PatchMyArcsByIdData, PatchMyArcsByIdErrors, PatchMyArcsByIdResponses, PatchMyBooksByIdData, PatchMyBooksByIdErrors, PatchMyBooksByIdResponses, PatchMyChaptersByIdData, PatchMyChaptersByIdErrors, PatchMyChaptersByIdResponses, PatchMyCharactersByCharacterIdInventoryByIdData, PatchMyCharactersByCharacterIdInventoryByIdErrors, PatchMyCharactersByCharacterIdInventoryByIdResponses, PatchMyCharactersByIdData, PatchMyCharactersByIdErrors, PatchMyCharactersByIdResponses, PatchMyContextItemsByIdData, PatchMyContextItemsByIdErrors, PatchMyContextItemsByIdResponses, PatchMyMessagesByIdData, PatchMyMessagesByIdErrors, PatchMyMessagesByIdResponses, PatchMyParagraphsByIdData, PatchMyParagraphsByIdErrors, PatchMyParagraphsByIdResponses, PatchMyScenesByIdData, PatchMyScenesByIdErrors, PatchMyScenesByIdResponses, PatchMyStoriesByIdData, PatchMyStoriesByIdErrors, PatchMyStoriesByIdResponses, PostAuthLoginData, PostAuthLoginErrors, PostAuthLoginResponses, PostAuthLogoutData, PostAuthLogoutResponses, PostAuthRegisterData, PostAuthRegisterErrors, PostAuthRegisterResponses, PostMyArcsByArcIdChaptersData, PostMyArcsByArcIdChaptersErrors, PostMyArcsByArcIdChaptersResponses, PostMyBooksByBookIdArcsData, PostMyBooksByBookIdArcsErrors, PostMyBooksByBookIdArcsResponses, PostMyChaptersByChapterIdScenesData, PostMyChaptersByChapterIdScenesErrors, PostMyChaptersByChapterIdScenesResponses, PostMyCharactersByCharacterIdInventoryData, PostMyCharactersByCharacterIdInventoryErrors, PostMyCharactersByCharacterIdInventoryResponses, PostMyFilesData, PostMyFilesErrors, PostMyFilesResponses, PostMyMapsByMapIdLandmarksData, PostMyMapsByMapIdLandmarksErrors, PostMyMapsByMapIdLandmarksResponses, PostMyMapsByMapIdPathsData, PostMyMapsByMapIdPathsErrors, PostMyMapsByMapIdPathsResponses, PostMyMapsByMapIdPawnsData, PostMyMapsByMapIdPawnsErrors, PostMyMapsByMapIdPawnsResponses, PostMyMessageRevisionsByRevisionIdParagraphsData, PostMyMessageRevisionsByRevisionIdParagraphsErrors, PostMyMessageRevisionsByRevisionIdParagraphsResponses, PostMyMessagesByIdRegenerateData, PostMyMessagesByIdRegenerateErrors, PostMyMessagesByIdRegenerateResponses, PostMyPathsByPathIdSegmentsData, PostMyPathsByPathIdSegmentsErrors, PostMyPathsByPathIdSegmentsResponses, PostMyScenesBySceneIdMessagesData, PostMyScenesBySceneIdMessagesErrors, PostMyScenesBySceneIdMessagesResponses, PostMyStoriesByStoryIdBooksData, PostMyStoriesByStoryIdBooksErrors, PostMyStoriesByStoryIdBooksResponses, PostMyStoriesByStoryIdCalendarsData, PostMyStoriesByStoryIdCalendarsErrors, PostMyStoriesByStoryIdCalendarsResponses, PostMyStoriesByStoryIdCharactersData, PostMyStoriesByStoryIdCharactersErrors, PostMyStoriesByStoryIdCharactersResponses, PostMyStoriesByStoryIdContextItemsData, PostMyStoriesByStoryIdContextItemsErrors, PostMyStoriesByStoryIdContextItemsResponses, PostMyStoriesByStoryIdMapsData, PostMyStoriesByStoryIdMapsErrors, PostMyStoriesByStoryIdMapsResponses, PostMyStoriesByStoryIdTagsData, PostMyStoriesByStoryIdTagsErrors, PostMyStoriesByStoryIdTagsResponses, PostMyStoriesData, PostMyStoriesErrors, PostMyStoriesResponses, PostTagsData, PostTagsErrors, PostTagsResponses, PutMyCalendarsByIdData, PutMyCalendarsByIdErrors, PutMyCalendarsByIdResponses, PutMyLandmarksByIdData, PutMyLandmarksByIdErrors, PutMyLandmarksByIdResponses, PutMyMapsByIdData, PutMyMapsByIdErrors, PutMyMapsByIdResponses, PutMyPathsByIdData, PutMyPathsByIdErrors, PutMyPathsByIdResponses, PutMyPathSegmentsByIdData, PutMyPathSegmentsByIdErrors, PutMyPathSegmentsByIdResponses, PutMyPawnsByIdData, PutMyPawnsByIdErrors, PutMyPawnsByIdResponses, PutMyStoriesByStoryIdDefaultCalendarData, PutMyStoriesByStoryIdDefaultCalendarErrors, PutMyStoriesByStoryIdDefaultCalendarResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Health check endpoint
 */
export const getHealth = <ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>) => (options?.client ?? client).get<GetHealthResponses, unknown, ThrowOnError>({ url: '/health', ...options });

/**
 * Register a new user account
 */
export const postAuthRegister = <ThrowOnError extends boolean = false>(options: Options<PostAuthRegisterData, ThrowOnError>) => (options.client ?? client).post<PostAuthRegisterResponses, PostAuthRegisterErrors, ThrowOnError>({
    url: '/auth/register',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Login to an existing account
 */
export const postAuthLogin = <ThrowOnError extends boolean = false>(options: Options<PostAuthLoginData, ThrowOnError>) => (options.client ?? client).post<PostAuthLoginResponses, PostAuthLoginErrors, ThrowOnError>({
    url: '/auth/login',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Logout and invalidate current session
 */
export const postAuthLogout = <ThrowOnError extends boolean = false>(options?: Options<PostAuthLogoutData, ThrowOnError>) => (options?.client ?? client).post<PostAuthLogoutResponses, unknown, ThrowOnError>({ url: '/auth/logout', ...options });

/**
 * Check current session status and get user info
 */
export const getAuthSession = <ThrowOnError extends boolean = false>(options?: Options<GetAuthSessionData, ThrowOnError>) => (options?.client ?? client).get<GetAuthSessionResponses, unknown, ThrowOnError>({ url: '/auth/session', ...options });

/**
 * List all stories owned by the authenticated user
 */
export const getMyStories = <ThrowOnError extends boolean = false>(options?: Options<GetMyStoriesData, ThrowOnError>) => (options?.client ?? client).get<GetMyStoriesResponses, GetMyStoriesErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/',
    ...options
});

/**
 * Create a new story
 */
export const postMyStories = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesResponses, PostMyStoriesErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a story (must be owned by authenticated user)
 */
export const deleteMyStoriesById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyStoriesByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyStoriesByIdResponses, DeleteMyStoriesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{id}',
    ...options
});

/**
 * Get a single story by ID (must be owned by authenticated user)
 */
export const getMyStoriesById = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByIdResponses, GetMyStoriesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{id}',
    ...options
});

/**
 * Update a story (must be owned by authenticated user)
 */
export const patchMyStoriesById = <ThrowOnError extends boolean = false>(options: Options<PatchMyStoriesByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyStoriesByIdResponses, PatchMyStoriesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Export complete story with all nested data (books, arcs, chapters, scenes, messages, characters, etc.)
 */
export const getMyStoriesByIdExport = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByIdExportData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByIdExportResponses, GetMyStoriesByIdExportErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{id}/export',
    ...options
});

/**
 * List all books in a story
 */
export const getMyStoriesByStoryIdBooks = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdBooksData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdBooksResponses, GetMyStoriesByStoryIdBooksErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/books',
    ...options
});

/**
 * Create a new book in a story
 */
export const postMyStoriesByStoryIdBooks = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdBooksData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdBooksResponses, PostMyStoriesByStoryIdBooksErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/books',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a book (must own the parent story)
 */
export const deleteMyBooksById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyBooksByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyBooksByIdResponses, DeleteMyBooksByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/books/{id}',
    ...options
});

/**
 * Get a single book by ID (must own the parent story)
 */
export const getMyBooksById = <ThrowOnError extends boolean = false>(options: Options<GetMyBooksByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyBooksByIdResponses, GetMyBooksByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/books/{id}',
    ...options
});

/**
 * Update a book (must own the parent story)
 */
export const patchMyBooksById = <ThrowOnError extends boolean = false>(options: Options<PatchMyBooksByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyBooksByIdResponses, PatchMyBooksByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/books/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all arcs in a book
 */
export const getMyBooksByBookIdArcs = <ThrowOnError extends boolean = false>(options: Options<GetMyBooksByBookIdArcsData, ThrowOnError>) => (options.client ?? client).get<GetMyBooksByBookIdArcsResponses, GetMyBooksByBookIdArcsErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/books/{bookId}/arcs',
    ...options
});

/**
 * Create a new arc in a book
 */
export const postMyBooksByBookIdArcs = <ThrowOnError extends boolean = false>(options: Options<PostMyBooksByBookIdArcsData, ThrowOnError>) => (options.client ?? client).post<PostMyBooksByBookIdArcsResponses, PostMyBooksByBookIdArcsErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/books/{bookId}/arcs',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete an arc (must own the parent story)
 */
export const deleteMyArcsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyArcsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyArcsByIdResponses, DeleteMyArcsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/arcs/{id}',
    ...options
});

/**
 * Get a single arc by ID (must own the parent story)
 */
export const getMyArcsById = <ThrowOnError extends boolean = false>(options: Options<GetMyArcsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyArcsByIdResponses, GetMyArcsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/arcs/{id}',
    ...options
});

/**
 * Update an arc (must own the parent story)
 */
export const patchMyArcsById = <ThrowOnError extends boolean = false>(options: Options<PatchMyArcsByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyArcsByIdResponses, PatchMyArcsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/arcs/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all chapters in an arc
 */
export const getMyArcsByArcIdChapters = <ThrowOnError extends boolean = false>(options: Options<GetMyArcsByArcIdChaptersData, ThrowOnError>) => (options.client ?? client).get<GetMyArcsByArcIdChaptersResponses, GetMyArcsByArcIdChaptersErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/arcs/{arcId}/chapters',
    ...options
});

/**
 * Create a new chapter in an arc
 */
export const postMyArcsByArcIdChapters = <ThrowOnError extends boolean = false>(options: Options<PostMyArcsByArcIdChaptersData, ThrowOnError>) => (options.client ?? client).post<PostMyArcsByArcIdChaptersResponses, PostMyArcsByArcIdChaptersErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/arcs/{arcId}/chapters',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a chapter (must own the parent story)
 */
export const deleteMyChaptersById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyChaptersByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyChaptersByIdResponses, DeleteMyChaptersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/chapters/{id}',
    ...options
});

/**
 * Get a single chapter by ID (must own the parent story)
 */
export const getMyChaptersById = <ThrowOnError extends boolean = false>(options: Options<GetMyChaptersByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyChaptersByIdResponses, GetMyChaptersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/chapters/{id}',
    ...options
});

/**
 * Update a chapter (must own the parent story)
 */
export const patchMyChaptersById = <ThrowOnError extends boolean = false>(options: Options<PatchMyChaptersByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyChaptersByIdResponses, PatchMyChaptersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/chapters/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all scenes in a chapter
 */
export const getMyChaptersByChapterIdScenes = <ThrowOnError extends boolean = false>(options: Options<GetMyChaptersByChapterIdScenesData, ThrowOnError>) => (options.client ?? client).get<GetMyChaptersByChapterIdScenesResponses, GetMyChaptersByChapterIdScenesErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/chapters/{chapterId}/scenes',
    ...options
});

/**
 * Create a new scene in a chapter
 */
export const postMyChaptersByChapterIdScenes = <ThrowOnError extends boolean = false>(options: Options<PostMyChaptersByChapterIdScenesData, ThrowOnError>) => (options.client ?? client).post<PostMyChaptersByChapterIdScenesResponses, PostMyChaptersByChapterIdScenesErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/chapters/{chapterId}/scenes',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a scene (must own the parent story)
 */
export const deleteMyScenesById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyScenesByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyScenesByIdResponses, DeleteMyScenesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/scenes/{id}',
    ...options
});

/**
 * Get a single scene by ID (must own the parent story)
 */
export const getMyScenesById = <ThrowOnError extends boolean = false>(options: Options<GetMyScenesByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyScenesByIdResponses, GetMyScenesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/scenes/{id}',
    ...options
});

/**
 * Update a scene (must own the parent story)
 */
export const patchMyScenesById = <ThrowOnError extends boolean = false>(options: Options<PatchMyScenesByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyScenesByIdResponses, PatchMyScenesByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/scenes/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all characters in a story
 */
export const getMyStoriesByStoryIdCharacters = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdCharactersData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdCharactersResponses, GetMyStoriesByStoryIdCharactersErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/characters',
    ...options
});

/**
 * Create a new character in a story
 */
export const postMyStoriesByStoryIdCharacters = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdCharactersData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdCharactersResponses, PostMyStoriesByStoryIdCharactersErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/characters',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a character (must own the parent story)
 */
export const deleteMyCharactersById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyCharactersByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyCharactersByIdResponses, DeleteMyCharactersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/characters/{id}',
    ...options
});

/**
 * Get a single character by ID (must own the parent story)
 */
export const getMyCharactersById = <ThrowOnError extends boolean = false>(options: Options<GetMyCharactersByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyCharactersByIdResponses, GetMyCharactersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/characters/{id}',
    ...options
});

/**
 * Update a character (must own the parent story)
 */
export const patchMyCharactersById = <ThrowOnError extends boolean = false>(options: Options<PatchMyCharactersByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyCharactersByIdResponses, PatchMyCharactersByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/characters/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all context items in a story (with optional type filter)
 */
export const getMyStoriesByStoryIdContextItems = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdContextItemsData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdContextItemsResponses, GetMyStoriesByStoryIdContextItemsErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/context-items',
    ...options
});

/**
 * Create a new context item in a story
 */
export const postMyStoriesByStoryIdContextItems = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdContextItemsData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdContextItemsResponses, PostMyStoriesByStoryIdContextItemsErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/stories/{storyId}/context-items',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a context item (must own the parent story)
 */
export const deleteMyContextItemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyContextItemsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyContextItemsByIdResponses, DeleteMyContextItemsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/context-items/{id}',
    ...options
});

/**
 * Get a single context item by ID (must own the parent story)
 */
export const getMyContextItemsById = <ThrowOnError extends boolean = false>(options: Options<GetMyContextItemsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyContextItemsByIdResponses, GetMyContextItemsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/context-items/{id}',
    ...options
});

/**
 * Update a context item (must own the parent story)
 */
export const patchMyContextItemsById = <ThrowOnError extends boolean = false>(options: Options<PatchMyContextItemsByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyContextItemsByIdResponses, PatchMyContextItemsByIdErrors, ThrowOnError>({
    security: [{
            in: 'cookie',
            name: 'sessionToken',
            type: 'apiKey'
        }],
    url: '/my/context-items/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all messages in a scene (ordered by sortOrder)
 */
export const getMyScenesBySceneIdMessages = <ThrowOnError extends boolean = false>(options: Options<GetMyScenesBySceneIdMessagesData, ThrowOnError>) => (options.client ?? client).get<GetMyScenesBySceneIdMessagesResponses, GetMyScenesBySceneIdMessagesErrors, ThrowOnError>({ url: '/my/scenes/{sceneId}/messages', ...options });

/**
 * Create a new message in a scene (auto-creates initial MessageRevision v1)
 */
export const postMyScenesBySceneIdMessages = <ThrowOnError extends boolean = false>(options: Options<PostMyScenesBySceneIdMessagesData, ThrowOnError>) => (options.client ?? client).post<PostMyScenesBySceneIdMessagesResponses, PostMyScenesBySceneIdMessagesErrors, ThrowOnError>({
    url: '/my/scenes/{sceneId}/messages',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a message (cascades to all MessageRevisions and Paragraphs)
 */
export const deleteMyMessagesById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyMessagesByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyMessagesByIdResponses, DeleteMyMessagesByIdErrors, ThrowOnError>({ url: '/my/messages/{id}', ...options });

/**
 * Get a single message by ID
 */
export const getMyMessagesById = <ThrowOnError extends boolean = false>(options: Options<GetMyMessagesByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyMessagesByIdResponses, GetMyMessagesByIdErrors, ThrowOnError>({ url: '/my/messages/{id}', ...options });

/**
 * Update message metadata (instruction, script, sortOrder)
 */
export const patchMyMessagesById = <ThrowOnError extends boolean = false>(options: Options<PatchMyMessagesByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyMessagesByIdResponses, PatchMyMessagesByIdErrors, ThrowOnError>({
    url: '/my/messages/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all MessageRevisions for a message (ordered by version DESC)
 */
export const getMyMessagesByMessageIdRevisions = <ThrowOnError extends boolean = false>(options: Options<GetMyMessagesByMessageIdRevisionsData, ThrowOnError>) => (options.client ?? client).get<GetMyMessagesByMessageIdRevisionsResponses, GetMyMessagesByMessageIdRevisionsErrors, ThrowOnError>({ url: '/my/messages/{messageId}/revisions', ...options });

/**
 * Regenerate message content (creates new MessageRevision with incremented version)
 */
export const postMyMessagesByIdRegenerate = <ThrowOnError extends boolean = false>(options: Options<PostMyMessagesByIdRegenerateData, ThrowOnError>) => (options.client ?? client).post<PostMyMessagesByIdRegenerateResponses, PostMyMessagesByIdRegenerateErrors, ThrowOnError>({
    url: '/my/messages/{id}/regenerate',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all paragraphs in a message revision (ordered by sortOrder)
 */
export const getMyMessageRevisionsByRevisionIdParagraphs = <ThrowOnError extends boolean = false>(options: Options<GetMyMessageRevisionsByRevisionIdParagraphsData, ThrowOnError>) => (options.client ?? client).get<GetMyMessageRevisionsByRevisionIdParagraphsResponses, GetMyMessageRevisionsByRevisionIdParagraphsErrors, ThrowOnError>({ url: '/my/message-revisions/{revisionId}/paragraphs', ...options });

/**
 * Create a new paragraph in a message revision (auto-creates initial ParagraphRevision v1)
 */
export const postMyMessageRevisionsByRevisionIdParagraphs = <ThrowOnError extends boolean = false>(options: Options<PostMyMessageRevisionsByRevisionIdParagraphsData, ThrowOnError>) => (options.client ?? client).post<PostMyMessageRevisionsByRevisionIdParagraphsResponses, PostMyMessageRevisionsByRevisionIdParagraphsErrors, ThrowOnError>({
    url: '/my/message-revisions/{revisionId}/paragraphs',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a paragraph (cascades to all ParagraphRevisions)
 */
export const deleteMyParagraphsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyParagraphsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyParagraphsByIdResponses, DeleteMyParagraphsByIdErrors, ThrowOnError>({ url: '/my/paragraphs/{id}', ...options });

/**
 * Get a single paragraph by ID
 */
export const getMyParagraphsById = <ThrowOnError extends boolean = false>(options: Options<GetMyParagraphsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyParagraphsByIdResponses, GetMyParagraphsByIdErrors, ThrowOnError>({ url: '/my/paragraphs/{id}', ...options });

/**
 * Update paragraph (if body changes, creates new ParagraphRevision)
 */
export const patchMyParagraphsById = <ThrowOnError extends boolean = false>(options: Options<PatchMyParagraphsByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyParagraphsByIdResponses, PatchMyParagraphsByIdErrors, ThrowOnError>({
    url: '/my/paragraphs/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all ParagraphRevisions for a paragraph (ordered by version DESC)
 */
export const getMyParagraphsByParagraphIdRevisions = <ThrowOnError extends boolean = false>(options: Options<GetMyParagraphsByParagraphIdRevisionsData, ThrowOnError>) => (options.client ?? client).get<GetMyParagraphsByParagraphIdRevisionsResponses, GetMyParagraphsByParagraphIdRevisionsErrors, ThrowOnError>({ url: '/my/paragraphs/{paragraphId}/revisions', ...options });

/**
 * List user's files with pagination and optional story filter
 */
export const getMyFiles = <ThrowOnError extends boolean = false>(options?: Options<GetMyFilesData, ThrowOnError>) => (options?.client ?? client).get<GetMyFilesResponses, GetMyFilesErrors, ThrowOnError>({ url: '/my/files', ...options });

/**
 * Upload a file (image for cover art, character pictures, etc.)
 */
export const postMyFiles = <ThrowOnError extends boolean = false>(options?: Options<PostMyFilesData, ThrowOnError>) => (options?.client ?? client).post<PostMyFilesResponses, PostMyFilesErrors, ThrowOnError>({ url: '/my/files', ...options });

/**
 * Delete a file (removes from database and filesystem)
 */
export const deleteMyFilesById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyFilesByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyFilesByIdResponses, DeleteMyFilesByIdErrors, ThrowOnError>({ url: '/my/files/{id}', ...options });

/**
 * Get file metadata by ID
 */
export const getMyFilesById = <ThrowOnError extends boolean = false>(options: Options<GetMyFilesByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyFilesByIdResponses, GetMyFilesByIdErrors, ThrowOnError>({ url: '/my/files/{id}', ...options });

/**
 * List all items in a character's inventory
 */
export const getMyCharactersByCharacterIdInventory = <ThrowOnError extends boolean = false>(options: Options<GetMyCharactersByCharacterIdInventoryData, ThrowOnError>) => (options.client ?? client).get<GetMyCharactersByCharacterIdInventoryResponses, GetMyCharactersByCharacterIdInventoryErrors, ThrowOnError>({ url: '/my/characters/{characterId}/inventory', ...options });

/**
 * Add an item to a character's inventory
 */
export const postMyCharactersByCharacterIdInventory = <ThrowOnError extends boolean = false>(options: Options<PostMyCharactersByCharacterIdInventoryData, ThrowOnError>) => (options.client ?? client).post<PostMyCharactersByCharacterIdInventoryResponses, PostMyCharactersByCharacterIdInventoryErrors, ThrowOnError>({
    url: '/my/characters/{characterId}/inventory',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete an item from character inventory
 */
export const deleteMyCharactersByCharacterIdInventoryById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyCharactersByCharacterIdInventoryByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyCharactersByCharacterIdInventoryByIdResponses, DeleteMyCharactersByCharacterIdInventoryByIdErrors, ThrowOnError>({ url: '/my/characters/{characterId}/inventory/{id}', ...options });

/**
 * Get a single item from character inventory
 */
export const getMyCharactersByCharacterIdInventoryById = <ThrowOnError extends boolean = false>(options: Options<GetMyCharactersByCharacterIdInventoryByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyCharactersByCharacterIdInventoryByIdResponses, GetMyCharactersByCharacterIdInventoryByIdErrors, ThrowOnError>({ url: '/my/characters/{characterId}/inventory/{id}', ...options });

/**
 * Update an item in character inventory (set amount to 0 to remove)
 */
export const patchMyCharactersByCharacterIdInventoryById = <ThrowOnError extends boolean = false>(options: Options<PatchMyCharactersByCharacterIdInventoryByIdData, ThrowOnError>) => (options.client ?? client).patch<PatchMyCharactersByCharacterIdInventoryByIdResponses, PatchMyCharactersByCharacterIdInventoryByIdErrors, ThrowOnError>({
    url: '/my/characters/{characterId}/inventory/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all tags on a story
 */
export const getMyStoriesByStoryIdTags = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdTagsData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdTagsResponses, GetMyStoriesByStoryIdTagsErrors, ThrowOnError>({ url: '/my/stories/{storyId}/tags', ...options });

/**
 * Add a tag to a story (by tagId or tagName)
 */
export const postMyStoriesByStoryIdTags = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdTagsData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdTagsResponses, PostMyStoriesByStoryIdTagsErrors, ThrowOnError>({
    url: '/my/stories/{storyId}/tags',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Remove a tag from a story
 */
export const deleteMyStoriesByStoryIdTagsByTagId = <ThrowOnError extends boolean = false>(options: Options<DeleteMyStoriesByStoryIdTagsByTagIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyStoriesByStoryIdTagsByTagIdResponses, DeleteMyStoriesByStoryIdTagsByTagIdErrors, ThrowOnError>({ url: '/my/stories/{storyId}/tags/{tagId}', ...options });

/**
 * List all calendars for a story
 */
export const getMyStoriesByStoryIdCalendars = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdCalendarsData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdCalendarsResponses, GetMyStoriesByStoryIdCalendarsErrors, ThrowOnError>({ url: '/my/stories/{storyId}/calendars', ...options });

/**
 * Create a new calendar for a story
 */
export const postMyStoriesByStoryIdCalendars = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdCalendarsData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdCalendarsResponses, PostMyStoriesByStoryIdCalendarsErrors, ThrowOnError>({
    url: '/my/stories/{storyId}/calendars',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a calendar
 */
export const deleteMyCalendarsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyCalendarsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyCalendarsByIdResponses, DeleteMyCalendarsByIdErrors, ThrowOnError>({ url: '/my/calendars/{id}', ...options });

/**
 * Get a single calendar by ID
 */
export const getMyCalendarsById = <ThrowOnError extends boolean = false>(options: Options<GetMyCalendarsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyCalendarsByIdResponses, GetMyCalendarsByIdErrors, ThrowOnError>({ url: '/my/calendars/{id}', ...options });

/**
 * Update a calendar configuration
 */
export const putMyCalendarsById = <ThrowOnError extends boolean = false>(options: Options<PutMyCalendarsByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyCalendarsByIdResponses, PutMyCalendarsByIdErrors, ThrowOnError>({
    url: '/my/calendars/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Set the default calendar for a story
 */
export const putMyStoriesByStoryIdDefaultCalendar = <ThrowOnError extends boolean = false>(options: Options<PutMyStoriesByStoryIdDefaultCalendarData, ThrowOnError>) => (options.client ?? client).put<PutMyStoriesByStoryIdDefaultCalendarResponses, PutMyStoriesByStoryIdDefaultCalendarErrors, ThrowOnError>({
    url: '/my/stories/{storyId}/default-calendar',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all maps for a story
 */
export const getMyStoriesByStoryIdMaps = <ThrowOnError extends boolean = false>(options: Options<GetMyStoriesByStoryIdMapsData, ThrowOnError>) => (options.client ?? client).get<GetMyStoriesByStoryIdMapsResponses, GetMyStoriesByStoryIdMapsErrors, ThrowOnError>({ url: '/my/stories/{storyId}/maps', ...options });

/**
 * Create a new map for a story
 */
export const postMyStoriesByStoryIdMaps = <ThrowOnError extends boolean = false>(options: Options<PostMyStoriesByStoryIdMapsData, ThrowOnError>) => (options.client ?? client).post<PostMyStoriesByStoryIdMapsResponses, PostMyStoriesByStoryIdMapsErrors, ThrowOnError>({
    url: '/my/stories/{storyId}/maps',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a map
 */
export const deleteMyMapsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyMapsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyMapsByIdResponses, DeleteMyMapsByIdErrors, ThrowOnError>({ url: '/my/maps/{id}', ...options });

/**
 * Get a single map by ID
 */
export const getMyMapsById = <ThrowOnError extends boolean = false>(options: Options<GetMyMapsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyMapsByIdResponses, GetMyMapsByIdErrors, ThrowOnError>({ url: '/my/maps/{id}', ...options });

/**
 * Update a map
 */
export const putMyMapsById = <ThrowOnError extends boolean = false>(options: Options<PutMyMapsByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyMapsByIdResponses, PutMyMapsByIdErrors, ThrowOnError>({
    url: '/my/maps/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all landmarks on a map
 */
export const getMyMapsByMapIdLandmarks = <ThrowOnError extends boolean = false>(options: Options<GetMyMapsByMapIdLandmarksData, ThrowOnError>) => (options.client ?? client).get<GetMyMapsByMapIdLandmarksResponses, GetMyMapsByMapIdLandmarksErrors, ThrowOnError>({ url: '/my/maps/{mapId}/landmarks', ...options });

/**
 * Create a new landmark on a map
 */
export const postMyMapsByMapIdLandmarks = <ThrowOnError extends boolean = false>(options: Options<PostMyMapsByMapIdLandmarksData, ThrowOnError>) => (options.client ?? client).post<PostMyMapsByMapIdLandmarksResponses, PostMyMapsByMapIdLandmarksErrors, ThrowOnError>({
    url: '/my/maps/{mapId}/landmarks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a landmark
 */
export const deleteMyLandmarksById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyLandmarksByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyLandmarksByIdResponses, DeleteMyLandmarksByIdErrors, ThrowOnError>({ url: '/my/landmarks/{id}', ...options });

/**
 * Get a single landmark by ID
 */
export const getMyLandmarksById = <ThrowOnError extends boolean = false>(options: Options<GetMyLandmarksByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyLandmarksByIdResponses, GetMyLandmarksByIdErrors, ThrowOnError>({ url: '/my/landmarks/{id}', ...options });

/**
 * Update a landmark
 */
export const putMyLandmarksById = <ThrowOnError extends boolean = false>(options: Options<PutMyLandmarksByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyLandmarksByIdResponses, PutMyLandmarksByIdErrors, ThrowOnError>({
    url: '/my/landmarks/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all pawns on a map
 */
export const getMyMapsByMapIdPawns = <ThrowOnError extends boolean = false>(options: Options<GetMyMapsByMapIdPawnsData, ThrowOnError>) => (options.client ?? client).get<GetMyMapsByMapIdPawnsResponses, GetMyMapsByMapIdPawnsErrors, ThrowOnError>({ url: '/my/maps/{mapId}/pawns', ...options });

/**
 * Create a new pawn on a map
 */
export const postMyMapsByMapIdPawns = <ThrowOnError extends boolean = false>(options: Options<PostMyMapsByMapIdPawnsData, ThrowOnError>) => (options.client ?? client).post<PostMyMapsByMapIdPawnsResponses, PostMyMapsByMapIdPawnsErrors, ThrowOnError>({
    url: '/my/maps/{mapId}/pawns',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a pawn
 */
export const deleteMyPawnsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyPawnsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyPawnsByIdResponses, DeleteMyPawnsByIdErrors, ThrowOnError>({ url: '/my/pawns/{id}', ...options });

/**
 * Get a single pawn by ID
 */
export const getMyPawnsById = <ThrowOnError extends boolean = false>(options: Options<GetMyPawnsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyPawnsByIdResponses, GetMyPawnsByIdErrors, ThrowOnError>({ url: '/my/pawns/{id}', ...options });

/**
 * Update a pawn
 */
export const putMyPawnsById = <ThrowOnError extends boolean = false>(options: Options<PutMyPawnsByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyPawnsByIdResponses, PutMyPawnsByIdErrors, ThrowOnError>({
    url: '/my/pawns/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all paths on a map
 */
export const getMyMapsByMapIdPaths = <ThrowOnError extends boolean = false>(options: Options<GetMyMapsByMapIdPathsData, ThrowOnError>) => (options.client ?? client).get<GetMyMapsByMapIdPathsResponses, GetMyMapsByMapIdPathsErrors, ThrowOnError>({ url: '/my/maps/{mapId}/paths', ...options });

/**
 * Create a new path on a map
 */
export const postMyMapsByMapIdPaths = <ThrowOnError extends boolean = false>(options: Options<PostMyMapsByMapIdPathsData, ThrowOnError>) => (options.client ?? client).post<PostMyMapsByMapIdPathsResponses, PostMyMapsByMapIdPathsErrors, ThrowOnError>({
    url: '/my/maps/{mapId}/paths',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a path
 */
export const deleteMyPathsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyPathsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyPathsByIdResponses, DeleteMyPathsByIdErrors, ThrowOnError>({ url: '/my/paths/{id}', ...options });

/**
 * Get a single path by ID
 */
export const getMyPathsById = <ThrowOnError extends boolean = false>(options: Options<GetMyPathsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyPathsByIdResponses, GetMyPathsByIdErrors, ThrowOnError>({ url: '/my/paths/{id}', ...options });

/**
 * Update a path
 */
export const putMyPathsById = <ThrowOnError extends boolean = false>(options: Options<PutMyPathsByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyPathsByIdResponses, PutMyPathsByIdErrors, ThrowOnError>({
    url: '/my/paths/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all segments for a path
 */
export const getMyPathsByPathIdSegments = <ThrowOnError extends boolean = false>(options: Options<GetMyPathsByPathIdSegmentsData, ThrowOnError>) => (options.client ?? client).get<GetMyPathsByPathIdSegmentsResponses, GetMyPathsByPathIdSegmentsErrors, ThrowOnError>({ url: '/my/paths/{pathId}/segments', ...options });

/**
 * Create a new segment for a path
 */
export const postMyPathsByPathIdSegments = <ThrowOnError extends boolean = false>(options: Options<PostMyPathsByPathIdSegmentsData, ThrowOnError>) => (options.client ?? client).post<PostMyPathsByPathIdSegmentsResponses, PostMyPathsByPathIdSegmentsErrors, ThrowOnError>({
    url: '/my/paths/{pathId}/segments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a path segment
 */
export const deleteMyPathSegmentsById = <ThrowOnError extends boolean = false>(options: Options<DeleteMyPathSegmentsByIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteMyPathSegmentsByIdResponses, DeleteMyPathSegmentsByIdErrors, ThrowOnError>({ url: '/my/path-segments/{id}', ...options });

/**
 * Get a single path segment by ID
 */
export const getMyPathSegmentsById = <ThrowOnError extends boolean = false>(options: Options<GetMyPathSegmentsByIdData, ThrowOnError>) => (options.client ?? client).get<GetMyPathSegmentsByIdResponses, GetMyPathSegmentsByIdErrors, ThrowOnError>({ url: '/my/path-segments/{id}', ...options });

/**
 * Update a path segment
 */
export const putMyPathSegmentsById = <ThrowOnError extends boolean = false>(options: Options<PutMyPathSegmentsByIdData, ThrowOnError>) => (options.client ?? client).put<PutMyPathSegmentsByIdResponses, PutMyPathSegmentsByIdErrors, ThrowOnError>({
    url: '/my/path-segments/{id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Browse published stories (public, no authentication required)
 */
export const getStories = <ThrowOnError extends boolean = false>(options?: Options<GetStoriesData, ThrowOnError>) => (options?.client ?? client).get<GetStoriesResponses, GetStoriesErrors, ThrowOnError>({ url: '/stories/', ...options });

/**
 * View a single published story (public, no authentication required)
 */
export const getStoriesById = <ThrowOnError extends boolean = false>(options: Options<GetStoriesByIdData, ThrowOnError>) => (options.client ?? client).get<GetStoriesByIdResponses, GetStoriesByIdErrors, ThrowOnError>({ url: '/stories/{id}', ...options });

/**
 * List all available tags (global, shared across all users)
 */
export const getTags = <ThrowOnError extends boolean = false>(options?: Options<GetTagsData, ThrowOnError>) => (options?.client ?? client).get<GetTagsResponses, unknown, ThrowOnError>({ url: '/tags', ...options });

/**
 * Create a new tag or get existing one (idempotent, returns existing if tag name already exists)
 */
export const postTags = <ThrowOnError extends boolean = false>(options: Options<PostTagsData, ThrowOnError>) => (options.client ?? client).post<PostTagsResponses, PostTagsErrors, ThrowOnError>({
    url: '/tags',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get all available calendar presets
 */
export const getCalendarsPresets = <ThrowOnError extends boolean = false>(options?: Options<GetCalendarsPresetsData, ThrowOnError>) => (options?.client ?? client).get<GetCalendarsPresetsResponses, GetCalendarsPresetsErrors, ThrowOnError>({ url: '/calendars/presets', ...options });
