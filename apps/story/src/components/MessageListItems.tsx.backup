import { For, createMemo } from "solid-js";
import { Message as MessageType, Chapter } from "../types/core";
import { Message } from "./Message";
import { ChapterHeader } from "./ChapterHeader";
import { InsertMessageButton } from "./InsertMessageButton";
import { InsertChapterButton } from "./InsertChapterButton";
import { ImportChapterButton } from "./ImportChapterButton";
import { InsertEventButton } from "./InsertEventButton";
import { generateMessageId } from "../utils/id";
import { messagesStore } from "../stores/messagesStore";
import { chaptersStore } from "../stores/chaptersStore";
import styles from "./MessageListItems.module.css";
import { currentStoryStore } from "../stores/currentStoryStore";

interface MessageListItemsProps {
    messagesInContext: Set<string>;
    storyTurnNumbers: Map<string, number>;
    totalStoryTurns: number;
    isGenerating: boolean;
    onDeleteMessage: (id: string) => void;
    onUpdateMessage: (id: string, updates: Partial<MessageType>) => void;
    onRegenerateFromMessage: (messageId: string) => void;
    onRegenerateQuery: (messageId: string) => void;
    onSummarizeMessage: (messageId: string) => void;
    onAnalyzeMessage: (messageId: string) => void;
    onRewriteMessage?: (messageId: string) => void;
    onEditChapterTitle: (chapter: Chapter) => void;
    onDeleteChapter: (chapter: Chapter) => void;
    onGenerateChapterSummary: (chapterId: string) => void;
    onCopyChapter?: (chapter: Chapter) => void;
    onMoveChapterUp?: (chapter: Chapter) => void;
    onMoveChapterDown?: (chapter: Chapter) => void;
}

type RenderableItems = Array<
    | {
          type: "chapter-header";
          data: Chapter;
          messageCount?: number;
          isExpanded: boolean;
      }
    | {
          type: "message";
          data: MessageType;
          isExpanded: boolean;
      }
>;

export default function MessageListItems(props: MessageListItemsProps) {
    // Create a map of chapter IDs to their data for efficient lookup
    const chapterDataMap = createMemo(() => {
        const chapters = chaptersStore.state.chapters;
        const map = new Map<string, Chapter>();

        // Add real chapters
        chapters.forEach((ch) => map.set(ch.id, ch));

        // Add placeholder chapters from chapter markers (use raw messages to ensure we don't miss any)
        messagesStore.messages.forEach((msg) => {
            if (
                msg.type === "chapter" &&
                msg.chapterId &&
                !map.has(msg.chapterId)
            ) {
                map.set(msg.chapterId, {
                    id: msg.chapterId,
                    storyId: currentStoryStore.id || "",
                    title: "Missing Chapter",
                    summary: undefined,
                    order: 0,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    isPlaceholder: true,
                } as Chapter);
            }
        });

        return map;
    });

    // Get chapter order from actual message positions
    const chapterOrder = createMemo(() => {
        const order: string[] = [];
        messagesStore.messages.forEach(msg => {
            if (msg.type === 'chapter' && msg.chapterId && !order.includes(msg.chapterId)) {
                order.push(msg.chapterId);
            }
        });
        return order;
    });

    // Create a flat list of renderable items (chapter headers and messages)
    const renderableItems = createMemo((): RenderableItems => {
        const items: RenderableItems = [];

        // Get only visible messages (excludes compacted ones)
        const visibleMessages = messagesStore.getVisibleMessages();

        // Count messages per chapter (only visible messages)
        const messageCountByChapter = new Map<string, number>();
        visibleMessages.forEach((msg) => {
            if (msg.chapterId && msg.type !== "chapter") {
                messageCountByChapter.set(
                    msg.chapterId,
                    (messageCountByChapter.get(msg.chapterId) || 0) + 1,
                );
            }
        });

        // Process messages and insert chapter headers
        visibleMessages.forEach((message) => {
            // Handle chapter marker messages
            if (message.type === "chapter" && message.chapterId) {
                const chapterData = chapterDataMap().get(message.chapterId);

                if (chapterData) {
                    items.push({
                        type: "chapter-header",
                        data: chapterData,
                        messageCount:
                            messageCountByChapter.get(message.chapterId) || 0,
                        isExpanded: chaptersStore.isChapterExpanded(
                            message.chapterId,
                        ),
                    });
                }
            } else {
                // Regular message
                items.push({
                    type: "message",
                    data: message,
                    isExpanded:
                        !message.chapterId ||
                        chaptersStore.isChapterExpanded(message.chapterId),
                });
            }
        });

        return items;
    });

    return (
        <For each={renderableItems()}>
            {(item) => {
                if (item.type === "chapter-header") {
                    const chapter = item.data as Chapter;

                    return (
                        <>
                            <ChapterHeader
                                chapter={chapter}
                                messageCount={item.messageCount || 0}
                                onEditTitle={props.onEditChapterTitle}
                                onDelete={props.onDeleteChapter}
                                onGenerateSummary={(chapter) =>
                                    props.onGenerateChapterSummary(chapter.id)
                                }
                                onCopyChapter={props.onCopyChapter}
                                onMoveUp={props.onMoveChapterUp}
                                onMoveDown={props.onMoveChapterDown}
                                canMoveUp={chapterOrder().indexOf(chapter.id) > 0}
                                canMoveDown={chapterOrder().indexOf(chapter.id) < chapterOrder().length - 1 && chapterOrder().indexOf(chapter.id) !== -1}
                            />
                            {/* Show insert buttons if:
                                1. Chapter has no messages (messageCount === 0), OR
                                2. Chapter has messages but is collapsed (!isExpanded)
                            */}
                            {(item.messageCount === 0 || !item.isExpanded) ? (
                                <div class={styles.insertButtonsContainer}>
                                    <InsertMessageButton
                                        onInsert={() => {
                                            const chapterId = item.data.id;
                                            
                                            // Find where to insert the new message
                                            let afterMessageId: string | null = null;
                                            
                                            if (item.messageCount === 0) {
                                                // No messages in chapter, insert after chapter marker
                                                const markerMessage = messagesStore.messages.find(
                                                    (msg) => msg.type === "chapter" && msg.chapterId === chapterId
                                                );
                                                if (markerMessage) {
                                                    afterMessageId = markerMessage.id;
                                                }
                                            } else {
                                                // Chapter has messages, find the last one
                                                const chapterMessages = messagesStore.messages.filter(
                                                    (msg) => msg.chapterId === chapterId && msg.type !== "chapter"
                                                );
                                                if (chapterMessages.length > 0) {
                                                    afterMessageId = chapterMessages[chapterMessages.length - 1].id;
                                                }
                                            }
                                            
                                            if (!afterMessageId) {
                                                console.error("Could not find insertion point for chapter", chapterId);
                                                return;
                                            }
                                            
                                            const newMessage: MessageType = {
                                                id: generateMessageId(),
                                                role: "assistant",
                                                content: "",
                                                instruction: "test",
                                                timestamp: new Date(),
                                                isQuery: false,
                                                chapterId: chapterId,
                                            };
                                            messagesStore.insertMessage(afterMessageId, newMessage);
                                        }}
                                    />
                                    <InsertChapterButton
                                        afterMessageId={() => {
                                            const chapterId = item.data.id;
                                            
                                            // Find where to insert: after the last message in the chapter
                                            let afterMessageId: string | null = null;
                                            
                                            if (item.messageCount === 0) {
                                                // No messages in chapter, insert after chapter marker
                                                const markerMessage = messagesStore.messages.find(
                                                    (msg) => msg.type === "chapter" && msg.chapterId === chapterId
                                                );
                                                if (markerMessage) {
                                                    afterMessageId = markerMessage.id;
                                                }
                                            } else {
                                                // Chapter has messages, find the last one
                                                const chapterMessages = messagesStore.messages.filter(
                                                    (msg) => msg.chapterId === chapterId && msg.type !== "chapter"
                                                );
                                                if (chapterMessages.length > 0) {
                                                    afterMessageId = chapterMessages[chapterMessages.length - 1].id;
                                                }
                                            }
                                            
                                            return afterMessageId || undefined;
                                        }}
                                    />
                                    <ImportChapterButton
                                        afterMessageId={() => {
                                            const chapterId = item.data.id;
                                            
                                            // Find where to insert: after the last message in the chapter
                                            let afterMessageId: string | null = null;
                                            
                                            if (item.messageCount === 0) {
                                                // No messages in chapter, insert after chapter marker
                                                const markerMessage = messagesStore.messages.find(
                                                    (msg) => msg.type === "chapter" && msg.chapterId === chapterId
                                                );
                                                if (markerMessage) {
                                                    afterMessageId = markerMessage.id;
                                                }
                                            } else {
                                                // Chapter has messages, find the last one
                                                const chapterMessages = messagesStore.messages.filter(
                                                    (msg) => msg.chapterId === chapterId && msg.type !== "chapter"
                                                );
                                                if (chapterMessages.length > 0) {
                                                    afterMessageId = chapterMessages[chapterMessages.length - 1].id;
                                                }
                                            }
                                            
                                            return afterMessageId || undefined;
                                        }}
                                    />
                                    <InsertEventButton
                                        afterMessageId={() => {
                                            const chapterId = item.data.id;
                                            
                                            // Find where to insert: after the last message in the chapter
                                            let afterMessageId: string | null = null;
                                            
                                            if (item.messageCount === 0) {
                                                // No messages in chapter, insert after chapter marker
                                                const markerMessage = messagesStore.messages.find(
                                                    (msg) => msg.type === "chapter" && msg.chapterId === chapterId
                                                );
                                                if (markerMessage) {
                                                    afterMessageId = markerMessage.id;
                                                }
                                            } else {
                                                // Chapter has messages, find the last one
                                                const chapterMessages = messagesStore.messages.filter(
                                                    (msg) => msg.chapterId === chapterId && msg.type !== "chapter"
                                                );
                                                if (chapterMessages.length > 0) {
                                                    afterMessageId = chapterMessages[chapterMessages.length - 1].id;
                                                }
                                            }
                                            
                                            return afterMessageId || undefined;
                                        }}
                                    />
                                </div>
                            ) : null}
                        </>
                    );
                } else {
                    const message = item.data as MessageType;
                    // Check if this message belongs to a chapter
                    if (message.chapterId && !item.isExpanded) {
                        // Hide message if chapter is collapsed (including compaction summaries)
                        return null;
                    }
                    
                    return (
                        <>
                            <div class="message-wrapper">
                                <Message
                                    message={message}
                                    isOutOfContext={
                                        !props.messagesInContext.has(message.id)
                                    }
                                    onDelete={props.onDeleteMessage}
                                    onUpdateMessage={(id, content, instruction) => {
                                        props.onUpdateMessage(id, { content, instruction })
                                    }}
                                    onRegenerateFromMessage={(id) => {
                                        // MessageListItems expects just the ID
                                        props.onRegenerateFromMessage(id)
                                    }}
                                    onRegenerateQuery={(id) => {
                                        // MessageListItems expects just the ID
                                        props.onRegenerateQuery(id)
                                    }}
                                    onSummarize={props.onSummarizeMessage}
                                    onAnalyze={props.onAnalyzeMessage}
                                    onRewrite={props.onRewriteMessage}
                                    storyTurnNumber={
                                        props.storyTurnNumbers.get(
                                            message.id,
                                        ) || 0
                                    }
                                    totalStoryTurns={props.totalStoryTurns}
                                    isGenerating={props.isGenerating}
                                />
                            </div>
                            <div class={styles.insertButtonsContainer}>
                                <InsertMessageButton
                                    onInsert={() => {
                                        const chapterId =
                                            messagesStore.getChapterIdForPosition(
                                                message.id,
                                            );
                                        const newMessage: MessageType = {
                                            id: generateMessageId(),
                                            role: "assistant",
                                            content: "",
                                            instruction: "test",
                                            timestamp: new Date(),
                                            isQuery: false,
                                            chapterId,
                                        };
                                        messagesStore.insertMessage(
                                            message.id,
                                            newMessage,
                                        );
                                    }}
                                />
                                <InsertChapterButton
                                    afterMessageId={message.id}
                                />
                                <ImportChapterButton
                                    afterMessageId={message.id}
                                />
                                <InsertEventButton
                                    afterMessageId={message.id}
                                />
                            </div>
                        </>
                    );
                }
            }}
        </For>
    );
}
