import {
  Component,
  Show,
  createSignal,
  onMount,
  onCleanup,
  createEffect,
  For,
  createMemo,
} from "solid-js";
import { mapsStore } from "../stores/mapsStore";
import { messagesStore } from "../stores/messagesStore";
import { nodeStore } from "../stores/nodeStore";
import { landmarkStatesStore } from "../stores/landmarkStatesStore";
import { settingsStore } from "../stores/settingsStore";
import { LANDMARK_STATE_FIELDS } from "../types/core";
import {
  BsPlus,
  BsTrash,
  BsPencil,
  BsX,
  BsCheck,
  BsArrowDown,
  BsArrowUp,
  BsChevronLeft,
  BsChevronRight,
  BsArrowReturnLeft,
  BsSearch,
} from "solid-icons/bs";
import { AiOutlineLoading3Quarters } from "solid-icons/ai";
import * as PIXI from "pixi.js";
import { Viewport } from "pixi-viewport";
import { Delaunay } from "d3-delaunay";
import { EJSCodeEditor } from "./EJSCodeEditor";
import { EJSRenderer } from "./EJSRenderer";
import { Landmark, LandmarkIndustry } from "../types/core";
import { evaluateTemplate } from "../utils/scriptEngine";
import { currentStoryStore } from "../stores/currentStoryStore";
import { scriptDataStore } from "../stores/scriptDataStore";
import { searchLandmarkInfo } from "../utils/landmarkSearch";
import { FactionOverlayControls } from "./maps/FactionOverlayControls";
import { MapTimeline } from "./maps/MapTimeline";
import { LandmarksList } from "./maps/LandmarksList";
import { MapControls } from "./maps/MapControls";
import { LandmarkPopup } from "./maps/LandmarkPopup";
import styles from "./Maps.module.css";

interface LandmarkSprite extends PIXI.Graphics {
  landmarkData?: Landmark;
  labelText?: PIXI.Text;
}

export const Maps: Component = () => {
  let canvasContainer: HTMLDivElement | undefined;
  let popupElement: HTMLDivElement | undefined;
  let pixiApp: PIXI.Application | null = null;
  let viewport: Viewport | null = null;
  let mapSprite: PIXI.Sprite | null = null;
  let landmarkContainer: PIXI.Container | null = null;
  let labelContainer: PIXI.Container | null = null;
  let voronoiContainer: PIXI.Container | null = null;
  let previewSprite: PIXI.Graphics | null = null;

  const [newMapName, setNewMapName] = createSignal("");
  const [newMapBorderColor, setNewMapBorderColor] = createSignal("");
  const [selectedFile, setSelectedFile] = createSignal<File | null>(null);
  const [selectedFileName, setSelectedFileName] = createSignal("");
  const [showAddMap, setShowAddMap] = createSignal(false);
  const [editingBorderColor, setEditingBorderColor] = createSignal(false);
  const [editBorderColorValue, setEditBorderColorValue] = createSignal("");
  const [selectedLandmark, setSelectedLandmark] = createSignal<Landmark | null>(
    null,
  );
  const [popupPosition, setPopupPosition] = createSignal({ x: 0, y: 0 });
  const [isEditing, setIsEditing] = createSignal(false);
  const [editName, setEditName] = createSignal("");
  const [editDescription, setEditDescription] = createSignal("");
  const [editColor, setEditColor] = createSignal("#3498db");
  const [editSize, setEditSize] = createSignal<"small" | "medium" | "large">(
    "medium",
  );
  const [editType, setEditType] = createSignal<"system" | "station" | "nebula">("system");
  const [editPopulation, setEditPopulation] = createSignal("");
  const [editIndustry, setEditIndustry] = createSignal<LandmarkIndustry | "">("");
  const [editPlanetaryBodies, setEditPlanetaryBodies] = createSignal("");
  const [populationError, setPopulationError] = createSignal("");
  // Remember last used settings for new landmarks (with localStorage persistence)
  const [lastUsedColor, setLastUsedColor] = createSignal(
    localStorage.getItem('lastLandmarkColor') || "#3498db"
  );
  const [lastUsedSize, setLastUsedSize] = createSignal<"small" | "medium" | "large">(
    (localStorage.getItem('lastLandmarkSize') as "small" | "medium" | "large") || "medium"
  );
  const [lastUsedType, setLastUsedType] = createSignal<"system" | "station" | "nebula">(
    (localStorage.getItem('lastLandmarkType') as "system" | "station" | "nebula") || "system"
  );
  const [isSaving, setIsSaving] = createSignal(false);
  const [isDeleting, setIsDeleting] = createSignal(false);
  const [isAddingNew, setIsAddingNew] = createSignal(false);
  const [newLandmarkPos, setNewLandmarkPos] = createSignal({ x: 0, y: 0 });
  const [sortAscending, setSortAscending] = createSignal(true);
  const [pendingTimelinePosition, setPendingTimelinePosition] = createSignal<number | null>(null);
  const [showFactionOverlay, setShowFactionOverlay] = createSignal(false);
  const [overlayMethod, setOverlayMethod] = createSignal<'voronoi' | 'metaball' | 'blurred' | 'noise'>('voronoi');
  const [selectedAllegiance, setSelectedAllegiance] = createSignal<string | null>(null);
  const [allegianceAtThisMessage, setAllegianceAtThisMessage] = createSignal<string | null>(null);
  const [allegianceSourceMessageId, setAllegianceSourceMessageId] = createSignal<string | null>(null);
  const [isSavingAllegiance, setIsSavingAllegiance] = createSignal(false);
  const [lastRenderedMessageId, setLastRenderedMessageId] = createSignal<string | null>(null);
  const [isFetchingLandmarkInfo, setIsFetchingLandmarkInfo] = createSignal(false);
  let timelineDebounceTimer: number | null = null;

  // Parse population string to number (removes commas, spaces, etc.)
  const parsePopulation = (value: string): number | null => {
    if (!value.trim()) return null;
    // Remove all non-digit characters except decimal point
    const cleaned = value.replace(/[^\d.]/g, '');
    const num = parseFloat(cleaned);
    return isNaN(num) ? null : num;
  };

  // Format number with thousand separators
  const formatPopulation = (num: number): string => {
    return new Intl.NumberFormat('en-US').format(num);
  };

  // Validate population input
  const validatePopulation = (value: string): boolean => {
    if (!value.trim()) return true; // Empty is valid (optional field)
    const parsed = parsePopulation(value);
    return parsed !== null && parsed >= 0;
  };

  // Handle population input change
  const handlePopulationInput = (value: string) => {
    setEditPopulation(value);
    if (value.trim() && !validatePopulation(value)) {
      setPopulationError("Please enter a valid number");
    } else {
      setPopulationError("");
    }
  };

  // Quick color picks
  const quickColors = [
    { name: "Red", hex: "#e74c3c" },
    { name: "Yellow", hex: "#f1c40f" },
    { name: "Purple", hex: "#9b59b6" },
    { name: "Orange", hex: "#e67e22" },
    { name: "Light Blue", hex: "#74c8eb" },
    { name: "Pink", hex: "#ff69b4" },
    { name: "Blue", hex: "#3498db" },
    { name: "White", hex: "#ffffff" },
  ];

  // Sorted landmarks for the list
  const sortedLandmarks = createMemo(() => {
    const map = mapsStore.selectedMap;
    if (!map) return [];

    const landmarks = [...map.landmarks];
    landmarks.sort((a, b) => {
      const comparison = a.name.localeCompare(b.name);
      return sortAscending() ? comparison : -comparison;
    });
    return landmarks;
  });

  // Get assistant messages for timeline
  const assistantMessages = createMemo(() => {
    return messagesStore.messages.filter(
      (m) => m.role === "assistant" && !m.isQuery,
    );
  });
  
  // Get current message ID based on timeline position
  const currentMessageId = createMemo(() => {
    const messages = assistantMessages();
    const position = mapsStore.timelinePosition;
    
    if (messages.length === 0) return null;
    
    // If position is -1 (latest) or beyond bounds, use last message
    const targetIndex =
      position < 0 || position >= messages.length
        ? messages.length - 1
        : position;
    
    return messages[targetIndex]?.id || null;
  });

  // Get current timeline message info (use pending position if dragging)
  const timelineMessageInfo = createMemo(() => {
    const messages = assistantMessages();
    const position = pendingTimelinePosition() !== null 
      ? pendingTimelinePosition()! 
      : mapsStore.timelinePosition;

    if (position < 0 || position >= messages.length) {
      return {
        position: `Latest (${messages.length})`,
        preview: '',
        chapter: ''
      };
    }

    const message = messages[position];
    const summary = message.summary || message.content;
    const preview = summary.slice(0, 60) + (summary.length > 60 ? "..." : "");
    
    // Get chapter info from nodes
    const chapterNode = message.nodeId
      ? nodeStore.nodesArray.find(n => n.id === message.nodeId && n.type === 'chapter')
      : message.chapterId
      ? nodeStore.nodesArray.find(n => n.id === message.chapterId && n.type === 'chapter')
      : null;
    const chapterInfo = chapterNode ? `Ch. ${chapterNode.title}` : '';
    
    return {
      position: `${position + 1}/${messages.length}`,
      preview,
      chapter: chapterInfo
    };
  });
  
  // Debounced timeline position update
  const handleTimelineChange = (value: number) => {
    // Update pending position immediately for UI feedback
    setPendingTimelinePosition(value);
    
    // Clear existing timer
    if (timelineDebounceTimer !== null) {
      clearTimeout(timelineDebounceTimer);
    }
    
    // Set new timer to update actual position after delay
    timelineDebounceTimer = window.setTimeout(() => {
      mapsStore.setTimelinePosition(value);
      setPendingTimelinePosition(null);
      timelineDebounceTimer = null;
    }, 500); // 500ms delay
  };
  
  // Step forward/back in timeline
  const stepTimeline = (direction: 'forward' | 'back') => {
    const messages = assistantMessages();
    const currentPos = mapsStore.timelinePosition < 0 
      ? messages.length - 1 
      : mapsStore.timelinePosition;
    
    let newPos = currentPos;
    if (direction === 'forward') {
      newPos = Math.min(currentPos + 1, messages.length - 1);
    } else {
      newPos = Math.max(currentPos - 1, 0);
    }
    
    // Clear any pending changes
    if (timelineDebounceTimer !== null) {
      clearTimeout(timelineDebounceTimer);
      timelineDebounceTimer = null;
    }
    setPendingTimelinePosition(null);
    
    // Update position directly
    mapsStore.setTimelinePosition(newPos);
  };
  
  // Jump to a specific message
  const jumpToMessage = (messageId: string) => {
    const messages = assistantMessages();
    const index = messages.findIndex(m => m.id === messageId);
    
    if (index >= 0) {
      // Clear any pending changes
      if (timelineDebounceTimer !== null) {
        clearTimeout(timelineDebounceTimer);
        timelineDebounceTimer = null;
      }
      setPendingTimelinePosition(null);
      
      // Update position directly
      mapsStore.setTimelinePosition(index);
    }
  };

  // Cache script execution data via scriptDataStore so we don't re-run scripts
  // for every landmark render (expensive with hundreds of landmarks)
  const scriptDataAtTimeline = createMemo(() => {
    const messages = assistantMessages();
    const position = mapsStore.timelinePosition;

    if (messages.length === 0) {
      return {};
    }

    // If position is -1 (latest) or beyond bounds, use last message
    const targetIndex =
      position < 0 || position >= messages.length
        ? messages.length - 1
        : position;

    const targetMessage = messages[targetIndex];
    if (!targetMessage) {
      return {};
    }

    const cached = scriptDataStore.getCumulativeDataAtMessage(targetMessage.id);
    return cached ? cached : {};
  });

  // Helper to keep existing call sites simple
  const getScriptDataAtTimeline = () => scriptDataAtTimeline();

  // Evaluate border color for a landmark
  const evaluateLandmarkBorderColor = (landmarkName: string): string => {
    const map = mapsStore.selectedMap;
    if (!map?.borderColor) return "";

    const scriptData = getScriptDataAtTimeline();
    
    // Get the allegiance for this landmark
    const landmark = map.landmarks.find(l => l.name === landmarkName);
    const allegiance = landmark 
      ? landmarkStatesStore.getLandmarkState(map.id, landmark.id, 'allegiance')
      : null;
    
    // Build a systems object from all landmark states
    const systems: Record<string, string> = {};
    for (const l of map.landmarks) {
      const state = landmarkStatesStore.getLandmarkState(map.id, l.id, 'allegiance');
      if (state) {
        systems[l.name] = state;
      }
    }
    
    const dataWithContext = {
      ...scriptData,
      currentSystemName: landmarkName,
      currentAllegiance: allegiance,
      systems, // Now populated from landmark states instead of scripts
    };

    try {
      const result = evaluateTemplate(map.borderColor, dataWithContext);
      console.log(`Template result for ${landmarkName}: "${result}"`);
      return result.trim();
    } catch (error) {
      console.error("Error evaluating border color:", error);
      return "";
    }
  };

  // Parse color string to hex number
  const parseColorToHex = (colorString: string): number => {
    if (!colorString) return 0x000000;
    
    try {
      if (colorString.startsWith("#")) {
        // Remove # and parse as hex
        const hexString = colorString.replace("#", "");
        return parseInt(hexString, 16);
      } else {
        // Handle named colors by using a temporary canvas
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.fillStyle = colorString;
          const computedColor = ctx.fillStyle;
          if (computedColor.startsWith("#")) {
            const hexString = computedColor.replace("#", "");
            return parseInt(hexString, 16);
          }
        }
      }
    } catch (e) {
      console.error("Error parsing color:", e);
    }
    
    return 0x000000;
  };

  // Get landmarks with colors for overlay
  const getLandmarksWithColors = () => {
    if (!mapSprite || !mapsStore.selectedMap) return [];
    
    const landmarksWithColors: { x: number; y: number; color: number; name: string }[] = [];
    
    mapsStore.selectedMap.landmarks.forEach((landmark) => {
      const borderColor = evaluateLandmarkBorderColor(landmark.name);
      if (borderColor && borderColor !== "") {
        const hexColor = parseColorToHex(borderColor);
        landmarksWithColors.push({
          x: landmark.x * mapSprite!.width,
          y: landmark.y * mapSprite!.height,
          color: hexColor,
          name: landmark.name,
        });
      }
    });
    
    return landmarksWithColors;
  };

  // Standard Voronoi visualization
  const drawStandardVoronoi = (landmarksWithColors: { x: number; y: number; color: number; name: string }[]) => {
    if (!voronoiContainer || !mapSprite || landmarksWithColors.length < 2) return;

    // Create Delaunay triangulation
    const points: [number, number][] = landmarksWithColors.map(l => [l.x, l.y] as [number, number]);
    const delaunay = Delaunay.from(points);
    
    // Create Voronoi diagram with bounds
    const voronoi = delaunay.voronoi([0, 0, mapSprite.width, mapSprite.height]);

    // Draw Voronoi cells - create a separate Graphics object for each cell
    for (let i = 0; i < landmarksWithColors.length; i++) {
      const cell = voronoi.cellPolygon(i);
      if (cell && cell.length > 0) {
        const cellGraphics = new PIXI.Graphics();
        
        // Build the polygon path
        cellGraphics.poly(cell.flat());
        
        // Fill with semi-transparent color
        cellGraphics.fill({ color: landmarksWithColors[i].color, alpha: 0.2 });
        
        // For borders, use a lighter color for dark colors to ensure visibility
        const borderColor = landmarksWithColors[i].color;
        const isVeryDark = borderColor < 0x333333;
        
        // Draw border with appropriate color - use white for very dark colors
        cellGraphics.poly(cell.flat());
        cellGraphics.stroke({
          color: isVeryDark ? 0xffffff : borderColor,
          alpha: isVeryDark ? 0.3 : 0.5,
          width: 2
        });
        
        voronoiContainer.addChild(cellGraphics);
      }
    }
  };

  // Distance field visualization with progressive rendering
  let distanceFieldAnimationId: number | null = null;
  
  const drawDistanceField = (landmarksWithColors: { x: number; y: number; color: number; name: string }[]) => {
    if (!voronoiContainer || !mapSprite) return;

    // Cancel any existing progressive rendering
    if (distanceFieldAnimationId) {
      cancelAnimationFrame(distanceFieldAnimationId);
      distanceFieldAnimationId = null;
    }

    // Calculate average distance to nearest neighbor for adaptive radius
    let avgNearestDistance = 0;
    if (landmarksWithColors.length > 1) {
      for (const landmark of landmarksWithColors) {
        let minDist = Infinity;
        for (const other of landmarksWithColors) {
          if (other === landmark) continue;
          const dx = landmark.x - other.x;
          const dy = landmark.y - other.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) minDist = dist;
        }
        avgNearestDistance += minDist;
      }
      avgNearestDistance /= landmarksWithColors.length;
    } else if (landmarksWithColors.length === 1) {
      // Single point: use a fraction of map size
      avgNearestDistance = Math.min(mapSprite.width, mapSprite.height) * 0.3;
    }
    
    // Set influence radius to 1.5x average nearest neighbor distance
    const influenceRadius = avgNearestDistance * 1.5;
    
    // Adjust resolution based on density - minimum 3, maximum 30
    const resolution = Math.max(3, Math.min(30, avgNearestDistance / 15));
    const width = Math.ceil(mapSprite.width / resolution);
    const height = Math.ceil(mapSprite.height / resolution);
    
    console.log(`Distance field: ${width}x${height} grid (${width * height} cells), influence radius: ${influenceRadius.toFixed(0)}px, resolution: ${resolution}px`);
    
    // Log to check if opacity is being calculated
    console.log(`Starting distance field render with ${landmarksWithColors.length} landmarks`);
    
    const graphics = new PIXI.Graphics();
    
    // Progressive rendering state
    let currentRow = 0;
    const frameTimeBudget = 16; // 16ms for 60fps
    
    const renderChunk = () => {
      const startTime = performance.now();
      
      // Process rows until we run out of time budget
      while (currentRow < height) {
        const y = currentRow;
        
        for (let x = 0; x < width; x++) {
          const px = x * resolution + resolution / 2;
          const py = y * resolution + resolution / 2;
          
          // Calculate influences from all landmarks within 2x radius for color blending
          const influences: { color: number; distance: number; weight: number }[] = [];
          let totalWeight = 0;
          let minDistance = Infinity; // Track closest landmark for opacity
          
          for (const landmark of landmarksWithColors) {
            const dx = px - landmark.x;
            const dy = py - landmark.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Track minimum distance for opacity calculation (check ALL landmarks)
            if (distance < minDistance) {
              minDistance = distance;
            }
            
            // Only include in color blending if within 2x radius
            if (distance <= influenceRadius * 2) {
              // Single continuous weight formula - closer points always have more influence
              // Higher power = sharper territory boundaries
              const normalizedDist = distance / (influenceRadius * 2);
              const weight = Math.pow(1 - normalizedDist, 6); // Power of 6 for well-defined territories
              
              if (weight > 0) {
                influences.push({ color: landmark.color, distance, weight });
                totalWeight += weight;
              }
            }
          }
          
          // Skip if too far from any landmark (beyond 2x radius of closest)
          if (minDistance > influenceRadius * 2) continue;
          
          // Skip if no influences (can happen when all weights are too small)
          if (influences.length === 0) continue;
          
          // Blend colors based on weighted influences
          let r = 0, g = 0, b = 0;
          
          for (const influence of influences) {
            const normalizedWeight = influence.weight / totalWeight;
            const color = influence.color;
            
            // Extract RGB components
            r += ((color >> 16) & 0xff) * normalizedWeight;
            g += ((color >> 8) & 0xff) * normalizedWeight;
            b += (color & 0xff) * normalizedWeight;
          }
          
          // Combine RGB back to hex
          const blendedColor = ((Math.round(r) << 16) | (Math.round(g) << 8) | Math.round(b));
          
          // Simple opacity calculation based on distance to closest point
          let alpha: number;
          
          if (minDistance <= influenceRadius) {
            // Within influence radius: max opacity
            alpha = 0.5;
          } else if (minDistance <= influenceRadius * 2) {
            // Between 1x and 2x radius: linear falloff to 0
            const fadeDistance = minDistance - influenceRadius;
            const fadeRange = influenceRadius; // From 1x to 2x radius
            alpha = 0.5 * (1 - fadeDistance / fadeRange);
          } else {
            // Beyond 2x radius: invisible
            alpha = 0;
          }
          
          // Debug: log some samples to see what's happening
          if (x === Math.floor(width/2) && y % 20 === 0) {
            const zone = minDistance <= influenceRadius ? "INNER" : 
                        minDistance <= influenceRadius * 2 ? "FADE" : "OUT";
            if (zone === "FADE") {
              console.log(`Row ${y}: zone=${zone}, influences=${influences.length}, totalWeight=${totalWeight.toFixed(3)}, color=#${blendedColor.toString(16).padStart(6, '0')}, r=${r.toFixed(0)}, g=${g.toFixed(0)}, b=${b.toFixed(0)}, alpha=${alpha.toFixed(2)}`);
            }
          }
          
          if (alpha > 0.01) {
            graphics.rect(px - resolution/2, py - resolution/2, resolution, resolution);
            graphics.fill({ color: blendedColor, alpha });
          }
        }
        
        currentRow++;
        
        // Check if we've exceeded our time budget
        const elapsed = performance.now() - startTime;
        if (elapsed > frameTimeBudget && currentRow < height) {
          // Schedule next chunk
          distanceFieldAnimationId = requestAnimationFrame(renderChunk);
          return;
        }
      }
      
      // All done - apply blur and add to container
      const blurFilter = new PIXI.BlurFilter({
        strength: Math.max(1, resolution / 5),
        quality: 2
      });
      
      graphics.filters = [blurFilter];
      voronoiContainer!.addChild(graphics);
      distanceFieldAnimationId = null;
      
      console.log("Distance field rendering complete");
    };
    
    // Start progressive rendering
    distanceFieldAnimationId = requestAnimationFrame(renderChunk);
  };

  // Blurred Voronoi with gradients
  const drawBlurredVoronoi = (landmarksWithColors: { x: number; y: number; color: number; name: string }[]) => {
    if (!voronoiContainer || !mapSprite || landmarksWithColors.length < 2) return;

    // First draw standard Voronoi
    drawStandardVoronoi(landmarksWithColors);
    
    // Apply blur filter to the container
    const blurFilter = new PIXI.BlurFilter({
      strength: 8,
      quality: 4
    });
    
    voronoiContainer.filters = [blurFilter];
  };

  // Update overlay based on selected method
  const updateVoronoiOverlay = () => {
    if (!voronoiContainer || !mapSprite || !mapsStore.selectedMap) return;

    // Cancel any progressive rendering in progress
    if (distanceFieldAnimationId) {
      cancelAnimationFrame(distanceFieldAnimationId);
      distanceFieldAnimationId = null;
    }

    // Clear existing overlay and filters
    voronoiContainer.removeChildren();
    voronoiContainer.filters = [];

    // Only draw if overlay is enabled
    if (!showFactionOverlay()) return;

    const landmarksWithColors = getLandmarksWithColors();
    
    console.log("Overlay method:", overlayMethod());
    console.log("Landmarks with colors:", landmarksWithColors.map(l => ({
      name: l.name,
      color: `0x${l.color.toString(16).padStart(6, '0')}`
    })));

    // Need at least 1 point for metaballs, 2 for Voronoi
    if (landmarksWithColors.length === 0) return;
    
    switch (overlayMethod()) {
      case 'voronoi':
        if (landmarksWithColors.length >= 2) {
          drawStandardVoronoi(landmarksWithColors);
        }
        break;
      case 'metaball':
        drawDistanceField(landmarksWithColors);
        break;
      case 'blurred':
        if (landmarksWithColors.length >= 2) {
          drawBlurredVoronoi(landmarksWithColors);
        }
        break;
      case 'noise':
        // TODO: Implement noise-distorted Voronoi
        if (landmarksWithColors.length >= 2) {
          drawStandardVoronoi(landmarksWithColors);
        }
        break;
    }
  };

  // Initialize Pixi application
  const initializePixi = async () => {
    if (!canvasContainer || pixiApp) return;

    // Create Pixi application
    pixiApp = new PIXI.Application();
    await pixiApp.init({
      width: canvasContainer.clientWidth,
      height: canvasContainer.clientHeight,
      backgroundColor: 0x1a1a1a,
      antialias: true,
      resolution: window.devicePixelRatio || 1,
      autoDensity: true,
    });

    // Add canvas to container
    canvasContainer.appendChild(pixiApp.canvas as HTMLCanvasElement);

    // Create viewport
    viewport = new Viewport({
      screenWidth: canvasContainer.clientWidth,
      screenHeight: canvasContainer.clientHeight,
      worldWidth: 2000,
      worldHeight: 2000,
      events: pixiApp.renderer.events,
    });

    // Add viewport to stage
    pixiApp.stage.addChild(viewport as any);

    // Configure viewport interactions
    viewport.drag().pinch().wheel().decelerate().clampZoom({
      minScale: 0.1,
      maxScale: 5,
    });

    // Create container for Voronoi overlay (rendered first)
    voronoiContainer = new PIXI.Container();
    viewport.addChild(voronoiContainer);

    // Create container for landmarks
    landmarkContainer = new PIXI.Container();
    viewport.addChild(landmarkContainer);

    // Create container for labels (rendered on top of landmarks)
    labelContainer = new PIXI.Container();
    viewport.addChild(labelContainer);
    
    // Create preview sprite for placing landmarks
    previewSprite = new PIXI.Graphics();
    previewSprite.visible = false;
    previewSprite.eventMode = 'none'; // Make it non-interactive so it doesn't block clicks
    viewport.addChild(previewSprite);
    
    // Handle mouse move for preview
    viewport.on("pointermove", (e: any) => {
      if (!previewSprite || !mapSprite || !viewport) return;
      
      // Don't show hover preview when adding new landmark (handled by the effect)
      // Only show preview when just hovering over the map
      if (!isEditing() && !isAddingNew() && mapsStore.selectedMap) {
        // Get world position
        const worldPos = viewport.toWorld(e.global);
        
        // Calculate normalized position (0-1)
        const normalizedX = worldPos.x / mapSprite.width;
        const normalizedY = worldPos.y / mapSprite.height;
        
        // Keep preview within bounds
        if (normalizedX >= 0 && normalizedX <= 1 && normalizedY >= 0 && normalizedY <= 1) {
          // Update preview position
          previewSprite.position.set(worldPos.x, worldPos.y);
          previewSprite.visible = true;
          
          // Draw preview marker with current settings
          const radius = 12; // Default medium size
          
          previewSprite.clear();
          
          // Draw with dashed/dotted outline to indicate it's a preview
          previewSprite.lineStyle(2, 0xffffff, 0.3);
          previewSprite.drawCircle(0, 0, radius + 2);
          
          // Semi-transparent fill
          previewSprite.beginFill(0x3498db, 0.3);
          previewSprite.drawCircle(0, 0, radius);
          previewSprite.endFill();
          
          // Add type-specific overlays
          if (lastUsedType() === "station") {
            const barWidth = Math.max(2, radius / 3);
            const barHeight = radius * 2.2;
            
            previewSprite.beginFill(0xffffff, 0.3);
            previewSprite.drawRect(-barWidth/2, -barHeight/2, barWidth, barHeight);
            previewSprite.endFill();
          } else if (lastUsedType() === "nebula") {
            const barHeight = Math.max(2, radius / 4);
            const middleBarWidth = radius * 1.92; // Was 1.6, now 20% wider
            const outerBarWidth = radius * 1.44; // Was 1.2, now 20% wider
            const barSpacing = radius * 0.5;
            
            previewSprite.beginFill(0xffffff, 0.3);
            // Top bar
            previewSprite.drawRect(-outerBarWidth/2, -barSpacing - barHeight/2, outerBarWidth, barHeight);
            // Middle bar
            previewSprite.drawRect(-middleBarWidth/2, -barHeight/2, middleBarWidth, barHeight);
            // Bottom bar
            previewSprite.drawRect(-outerBarWidth/2, barSpacing - barHeight/2, outerBarWidth, barHeight);
            previewSprite.endFill();
          }
        } else {
          previewSprite.visible = false;
        }
      } else if (!isAddingNew()) {
        // Only hide if we're not adding a new landmark
        previewSprite.visible = false;
      }
    });
    
    // Detect if touch device
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    
    // For mobile: show preview on first tap, place on second tap
    // let previewTapLocation: { x: number, y: number } | null = null;
    
    // Track if user is dragging to distinguish from taps
    let isDragging = false;
    let dragStartPos: { x: number, y: number } | null = null;
    
    // Track drag start
    viewport.on("pointerdown", (e: any) => {
      if (!viewport) return;
      const worldPos = viewport.toWorld(e.global);
      dragStartPos = { x: worldPos.x, y: worldPos.y };
      isDragging = false;
    });
    
    // Detect if pointer moved enough to be considered a drag
    viewport.on("pointermove", (e: any) => {
      if (dragStartPos && !isDragging && viewport) {
        const worldPos = viewport.toWorld(e.global);
        const distance = Math.sqrt(
          Math.pow(worldPos.x - dragStartPos.x, 2) + 
          Math.pow(worldPos.y - dragStartPos.y, 2)
        );
        // Consider it a drag if moved more than 5 pixels
        if (distance > 5) {
          isDragging = true;
          // Hide preview if we're dragging
          if (previewSprite) {
            previewSprite.visible = false;
            // previewTapLocation = null;
          }
        }
      }
    });
    
    // Reset drag state on pointer up
    viewport.on("pointerup", () => {
      dragStartPos = null;
      // Small delay to let the clicked event know if it was a drag
      setTimeout(() => {
        isDragging = false;
      }, 50);
    });

    // Handle viewport clicks for adding landmarks
    viewport.on("clicked", (e: any) => {
      // Ignore if user was dragging
      if (isDragging) return;
      // e.event is the original DOM event, e.screen and e.world contain position info
      if (mapsStore.selectedMap && mapSprite) {
        // The viewport 'clicked' event provides world coordinates directly
        const worldPos = e.world || viewport!.toWorld(e.screen);

        // Convert to normalized coordinates (0-1)
        const normalizedX = worldPos.x / mapSprite.width;
        const normalizedY = worldPos.y / mapSprite.height;
        
        // Check bounds
        if (normalizedX < 0 || normalizedX > 1 || normalizedY < 0 || normalizedY > 1) {
          return;
        }
        
        // On mobile: if already adding, just update the position and popup location
        if (isTouchDevice && isAddingNew()) {
          // Update position of the new landmark
          setNewLandmarkPos({ x: normalizedX, y: normalizedY });
          
          // Update preview sprite position
          if (previewSprite) {
            previewSprite.position.set(worldPos.x, worldPos.y);
            previewSprite.visible = true;
          }
          
          // Update popup position for the new location
          const screenPos = e.screen || viewport!.toScreen(worldPos);
          const baseX = screenPos.x + (canvasContainer?.offsetLeft || 0);
          const baseY = screenPos.y + (canvasContainer?.offsetTop || 0);
          
          // Calculate with actual height if popup exists
          const actualHeight = popupElement?.offsetHeight;
          // Pass the click position relative to canvas for better detection
          setPopupPosition(calculateSafePopupPosition(baseX, baseY, true, actualHeight));
          
          // Don't reset form values
          return;
        }

        // Start adding a new landmark
        setNewLandmarkPos({ x: normalizedX, y: normalizedY });
        setEditName("");
        setEditDescription("");
        setEditPopulation("");
        setEditIndustry("");
        setEditPlanetaryBodies("");
        setPopulationError("");
        // Use last used settings for consistency
        setEditColor(lastUsedColor());
        setEditSize(lastUsedSize());
        setEditType(lastUsedType());
        setIsAddingNew(true);
        setIsEditing(true);
        setSelectedLandmark(null);

        // Show preview sprite immediately on all devices
        if (previewSprite) {
          previewSprite.position.set(worldPos.x, worldPos.y);
          previewSprite.visible = true;
        }
        
        // Position popup to avoid covering the marker
        const screenPos = e.screen || viewport!.toScreen(worldPos);
        const baseX = screenPos.x + (canvasContainer?.offsetLeft || 0);
        const baseY = screenPos.y + (canvasContainer?.offsetTop || 0);
        
        // Adjust position to account for marker size
        const markerRadius = 12; // medium size default
        
        // On mobile, use vertical positioning; on desktop, use horizontal
        if (isTouchDevice) {
          // Pass canvas-relative position for better detection
          setPopupPosition(calculateSafePopupPosition(baseX, baseY, true));
        } else {
          setPopupPosition(calculateSafePopupPosition(baseX + markerRadius + 80, baseY - markerRadius, false));
        }
      }
    });

    // Load current map if available
    if (mapsStore.selectedMap) {
      loadMap(mapsStore.selectedMap.imageData);
    }
  };

  // Load map image into viewport
  const loadMap = async (imageData: string) => {
    if (!viewport || !landmarkContainer) return;

    // Clear existing map
    if (mapSprite) {
      viewport.removeChild(mapSprite);
      mapSprite.destroy();
    }

    // Clear existing landmarks and labels
    landmarkContainer.removeChildren();
    if (labelContainer) {
      labelContainer.removeChildren();
    }

    // Load new map texture
    const texture = await PIXI.Assets.load(imageData);
    mapSprite = new PIXI.Sprite(texture);

    // Add map to viewport (behind landmarks)
    viewport.addChildAt(mapSprite, 0);

    // Fit viewport to map
    viewport.worldWidth = mapSprite.width;
    viewport.worldHeight = mapSprite.height;
    viewport.fit();
    viewport.moveCenter(mapSprite.width / 2, mapSprite.height / 2);

    // Load landmarks for this map
    if (mapsStore.selectedMap) {
      mapsStore.selectedMap.landmarks.forEach((landmark) => {
        addLandmarkSprite(landmark);
      });
      
      // Update Voronoi overlay
      updateVoronoiOverlay();
    }
  };

  // Add a landmark sprite to the map
  const addLandmarkSprite = (landmark: Landmark) => {
    if (!landmarkContainer || !mapSprite) return;

    const sprite = new PIXI.Graphics() as LandmarkSprite;
    // Store a copy of the landmark data, not a reference
    sprite.landmarkData = { ...landmark };

    // Determine size based on landmark size property
    const sizeMap = {
      small: 8,
      medium: 12,
      large: 16,
    };
    const radius = sizeMap[landmark.size || "medium"];

    // Clear any previous graphics
    sprite.clear();

    // Get border color from template (if any)
    const borderColor = evaluateLandmarkBorderColor(landmark.name);
    const hasBorderColor = borderColor && borderColor !== "";
    
    if (hasBorderColor) {
      console.log(`Landmark ${landmark.name} border color: ${borderColor}`);
      // Parse the color using helper function
      const borderColorHex = parseColorToHex(borderColor);
      console.log(
        `Parsed ${borderColor} to 0x${borderColorHex.toString(16)}`,
      );

      // Draw white border ring - same for both types
      sprite
        .circle(0, 0, radius - 1)
        .stroke({ width: 2, color: 0xffffff, alpha: 1 });

      sprite
        .circle(0, 0, radius - 1)
        .fill({ color: borderColorHex });
    }

    // Draw the filled pin center (this goes last so it's on top)
    const color = parseInt(landmark.color?.replace("#", "") || "3498db", 16);
    
    // Draw circle for all types
    const innerRadius = hasBorderColor ? radius - 3 : radius;
    sprite
      .circle(0, 0, innerRadius)
      .stroke({ width: 1, color: 0xffffff, alpha: 0.5 })
      .fill({ color });
    
    // Add type-specific overlays
    if (landmark.type === "station") {
      // Vertical bar for stations
      const barWidth = Math.max(2, radius / 3);
      const barHeight = radius * 2.2; // Use full radius and make it clearly extend beyond circle
      
      // Draw white outline for the bar (extend on all sides)
      sprite
        .rect(-barWidth/2 - 1, -barHeight/2 - 1, barWidth + 2, barHeight + 2)
        .fill({ color: 0xffffff, alpha: 0.8 });
      
      // Draw the colored bar
      sprite
        .rect(-barWidth/2, -barHeight/2, barWidth, barHeight)
        .fill({ color });
    } else if (landmark.type === "nebula") {
      // Three horizontal bars for nebula
      const barHeight = Math.max(2, radius / 4);
      const middleBarWidth = radius * 1.92; // Was 1.6, now 20% wider
      const outerBarWidth = radius * 1.44; // Was 1.2, now 20% wider
      const barSpacing = radius * 0.5;
      
      // Top bar (shorter)
      sprite
        .rect(-outerBarWidth/2 - 1, -barSpacing - barHeight/2 - 1, outerBarWidth + 2, barHeight + 2)
        .fill({ color: 0xffffff, alpha: 0.8 });
      sprite
        .rect(-outerBarWidth/2, -barSpacing - barHeight/2, outerBarWidth, barHeight)
        .fill({ color });
      
      // Middle bar (longer)
      sprite
        .rect(-middleBarWidth/2 - 1, -barHeight/2 - 1, middleBarWidth + 2, barHeight + 2)
        .fill({ color: 0xffffff, alpha: 0.8 });
      sprite
        .rect(-middleBarWidth/2, -barHeight/2, middleBarWidth, barHeight)
        .fill({ color });
      
      // Bottom bar (shorter)
      sprite
        .rect(-outerBarWidth/2 - 1, barSpacing - barHeight/2 - 1, outerBarWidth + 2, barHeight + 2)
        .fill({ color: 0xffffff, alpha: 0.8 });
      sprite
        .rect(-outerBarWidth/2, barSpacing - barHeight/2, outerBarWidth, barHeight)
        .fill({ color });
    }

    // Position based on normalized coordinates
    sprite.x = landmark.x * mapSprite.width;
    sprite.y = landmark.y * mapSprite.height;

    // Create label text (hidden by default)
    const labelText = new PIXI.Text(landmark.name, {
      fontSize: 14,
      fill: 0xffffff,
      stroke: {
        color: 0x000000,
        width: 3,
      },
      fontWeight: "bold",
      align: "center",
    });

    // Position label above the landmark
    labelText.anchor.set(0.5, 1);
    labelText.x = sprite.x;
    labelText.y = sprite.y - radius - 8;
    labelText.visible = false;

    // Store reference to label in sprite
    sprite.labelText = labelText;

    // Add label to label container (so it renders on top)
    if (labelContainer) {
      labelContainer.addChild(labelText);
    }

    // Make interactive
    sprite.eventMode = "static";
    sprite.cursor = "pointer";

    // Store original scale for hover effect
    const originalScale = 1;
    const hoverScale = 1.2;

    // Set initial alpha
    sprite.alpha = 0.8;

    // Add hover effects
    sprite.on("pointerover", () => {
      // Scale up and increase opacity on hover
      sprite.scale.set(hoverScale, hoverScale);
      sprite.alpha = 1; // Full opacity on hover
      // Show label
      if (sprite.labelText) {
        sprite.labelText.visible = true;
      }
    });

    sprite.on("pointerout", () => {
      // Return to original scale and opacity
      sprite.scale.set(originalScale, originalScale);
      sprite.alpha = 0.8; // Back to default transparency
      // Hide label
      if (sprite.labelText) {
        sprite.labelText.visible = false;
      }
    });

    // Handle click
    sprite.on("pointerdown", (e: PIXI.FederatedPointerEvent) => {
      e.stopPropagation();
      if ("preventDefault" in e) {
        (e as any).preventDefault();
      }
      setSelectedLandmark(landmark);
      setIsEditing(false);
      setIsAddingNew(false);

      // Position popup near the landmark
      if (!viewport) return;
      const screenPos = viewport.toScreen(sprite.position);
      const baseX = screenPos.x + (canvasContainer?.offsetLeft || 0);
      const baseY = screenPos.y + (canvasContainer?.offsetTop || 0);
      const isMobile = window.innerWidth < 768;
      setPopupPosition(calculateSafePopupPosition(baseX, baseY, isMobile));
    });

    landmarkContainer.addChild(sprite);
  };

  // Update landmarks and Voronoi when map changes, timeline position changes, borderColor changes, overlay toggle or method changes
  createEffect(() => {
    const map = mapsStore.selectedMap;
    // Track timeline changes - accessing this creates reactivity
    mapsStore.timelinePosition;
    // Track borderColor changes - accessing this creates reactivity
    map?.borderColor;
    // Track overlay toggle changes
    showFactionOverlay();
    // Track overlay method changes
    overlayMethod();
    // Track landmarks array changes - accessing length ensures we detect additions/removals
    map?.landmarks.length;
    // Track individual landmark changes by accessing their properties
    // This creates a dependency on each landmark's properties
    map?.landmarks.forEach(l => {
      l.name; l.description; l.color; l.size; l.x; l.y;
    });
    // Track when accumulated states are loaded for a new message
    landmarkStatesStore.currentMessageId;
    
    console.log('Landmark effect triggered, landmarks:', map?.landmarks.length, 'messageId:', landmarkStatesStore.currentMessageId);
    
    if (map && landmarkContainer && mapSprite) {
      // Check if we need to force re-render all (when timeline position or states changed)
      const currentMsgId = landmarkStatesStore.currentMessageId;
      const forceRerender = currentMsgId !== lastRenderedMessageId();
      
      if (forceRerender) {
        // Timeline changed, re-render everything since border colors might be different
        console.log('Force re-rendering all landmarks due to timeline/state change');
        landmarkContainer.removeChildren();
        if (labelContainer) {
          labelContainer.removeChildren();
        }
        map.landmarks.forEach((landmark) => {
          addLandmarkSprite(landmark);
        });
        setLastRenderedMessageId(currentMsgId);
      } else {
        // Normal incremental update
        const existingSprites = landmarkContainer.children as LandmarkSprite[];
        const existingLandmarksMap = new Map<string, LandmarkSprite>();
        
        for (const sprite of existingSprites) {
          if (sprite.landmarkData) {
            existingLandmarksMap.set(sprite.landmarkData.id, sprite);
          }
        }
        
        // Track which landmarks we've seen
        const seenLandmarkIds = new Set<string>();
        
        // Update or add landmarks
        for (const landmark of map.landmarks) {
          seenLandmarkIds.add(landmark.id);
          const existingSprite = existingLandmarksMap.get(landmark.id);
          
          if (existingSprite) {
            // Check if landmark has changed
            const oldData = existingSprite.landmarkData!;
            
            const hasChanged = 
              oldData.name !== landmark.name ||
              oldData.description !== landmark.description ||
              oldData.color !== landmark.color ||
              oldData.size !== landmark.size ||
              oldData.x !== landmark.x ||
              oldData.y !== landmark.y;
            
            if (hasChanged) {
            console.log(`Landmark ${landmark.name} changed:`, {
              color: oldData.color !== landmark.color ? `${oldData.color} -> ${landmark.color}` : 'unchanged',
              size: oldData.size !== landmark.size ? `${oldData.size} -> ${landmark.size}` : 'unchanged'
            });
            // Remove old sprite and its label
            landmarkContainer.removeChild(existingSprite);
            if (existingSprite.labelText && labelContainer) {
              labelContainer.removeChild(existingSprite.labelText);
            }
            // Add updated sprite
            addLandmarkSprite(landmark);
          } else {
            // Update the stored landmark data copy even if visual hasn't changed
            // This ensures the data stays in sync
            existingSprite.landmarkData = { ...landmark };
          }
        } else {
          // New landmark, add it
          addLandmarkSprite(landmark);
        }
      }
      
        // Remove landmarks that no longer exist
        for (const [id, sprite] of existingLandmarksMap) {
          if (!seenLandmarkIds.has(id)) {
            landmarkContainer.removeChild(sprite);
            if (sprite.labelText && labelContainer) {
              labelContainer.removeChild(sprite.labelText);
            }
          }
        }
      }
      
      // Update Voronoi overlay
      updateVoronoiOverlay();
    }
  });
  
  // Measure popup and update position when it's rendered or content changes
  createEffect(() => {
    if (popupElement && (selectedLandmark() || isAddingNew()) && viewport && mapSprite) {
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // Get the actual height of the popup
      const actualHeight = popupElement.offsetHeight;
      
      // Get current position (either selected landmark or new landmark position)
      let worldX: number, worldY: number;
      if (isAddingNew()) {
        const pos = newLandmarkPos();
        worldX = pos.x * mapSprite.width;
        worldY = pos.y * mapSprite.height;
      } else if (selectedLandmark()) {
        worldX = selectedLandmark()!.x * mapSprite.width;
        worldY = selectedLandmark()!.y * mapSprite.height;
      } else {
        return;
      }
      
      // Convert to screen coordinates
      const screenPos = viewport.toScreen(worldX, worldY);
      const baseX = screenPos.x + (canvasContainer?.offsetLeft || 0);
      const baseY = screenPos.y + (canvasContainer?.offsetTop || 0);
      
      // Pass canvas-relative position for mobile
      // Recalculate position with actual height
      const newPosition = calculateSafePopupPosition(baseX, baseY, isTouchDevice, actualHeight);
      
      // Only update if position changed significantly (to avoid infinite loops)
      const currentPos = popupPosition();
      if (Math.abs(newPosition.x - currentPos.x) > 1 || Math.abs(newPosition.y - currentPos.y) > 1) {
        setPopupPosition(newPosition);
      }
    }
  });
  
  // Show placement indicator when adding new landmark
  createEffect(() => {
    if (isAddingNew() && previewSprite && mapSprite) {
      const pos = newLandmarkPos();
      const worldX = pos.x * mapSprite.width;
      const worldY = pos.y * mapSprite.height;
      
      previewSprite.position.set(worldX, worldY);
      previewSprite.visible = true;
      
      // Draw placement indicator with current color/size
      const sizeMap = { small: 8, medium: 12, large: 16 };
      const radius = sizeMap[editSize()];
      const color = parseInt(editColor().replace("#", "") || "3498db", 16);
      
      previewSprite.clear();
      
      // Pulsing outline effect
      previewSprite.lineStyle(2, 0xffffff, 0.8);
      previewSprite.drawCircle(0, 0, radius + 3);
      
      // Semi-transparent preview
      previewSprite.beginFill(color, 0.6);
      previewSprite.drawCircle(0, 0, radius);
      previewSprite.endFill();
      
      // Add type-specific overlays
      if (editType() === "station") {
        const barWidth = Math.max(2, radius / 3);
        const barHeight = radius * 2.2;
        
        // White outline for the bar (extend on all sides)
        previewSprite.beginFill(0xffffff, 0.8);
        previewSprite.drawRect(-barWidth/2 - 1, -barHeight/2 - 1, barWidth + 2, barHeight + 2);
        previewSprite.endFill();
        
        // Colored bar
        previewSprite.beginFill(color, 0.6);
        previewSprite.drawRect(-barWidth/2, -barHeight/2, barWidth, barHeight);
        previewSprite.endFill();
      } else if (editType() === "nebula") {
        const barHeight = Math.max(2, radius / 4);
        const middleBarWidth = radius * 1.92; // Was 1.6, now 20% wider
        const outerBarWidth = radius * 1.44; // Was 1.2, now 20% wider
        const barSpacing = radius * 0.5;
        
        // Draw bars with white outlines
        previewSprite.beginFill(0xffffff, 0.8);
        // Top bar outline
        previewSprite.drawRect(-outerBarWidth/2 - 1, -barSpacing - barHeight/2 - 1, outerBarWidth + 2, barHeight + 2);
        // Middle bar outline
        previewSprite.drawRect(-middleBarWidth/2 - 1, -barHeight/2 - 1, middleBarWidth + 2, barHeight + 2);
        // Bottom bar outline
        previewSprite.drawRect(-outerBarWidth/2 - 1, barSpacing - barHeight/2 - 1, outerBarWidth + 2, barHeight + 2);
        previewSprite.endFill();
        
        // Colored bars
        previewSprite.beginFill(color, 0.6);
        // Top bar
        previewSprite.drawRect(-outerBarWidth/2, -barSpacing - barHeight/2, outerBarWidth, barHeight);
        // Middle bar
        previewSprite.drawRect(-middleBarWidth/2, -barHeight/2, middleBarWidth, barHeight);
        // Bottom bar
        previewSprite.drawRect(-outerBarWidth/2, barSpacing - barHeight/2, outerBarWidth, barHeight);
        previewSprite.endFill();
      }
    } else if (previewSprite) {
      // Hide preview when not adding new
      previewSprite.visible = false;
    }
  });

  // Handle file selection
  const handleFileSelect = (e: Event) => {
    const input = e.target as HTMLInputElement;
    const file = input.files?.[0];
    if (file && file.type.startsWith("image/")) {
      setSelectedFile(file);
      setSelectedFileName(file.name);
    }
  };

  // Add new map
  const handleAddMap = async () => {
    const name = newMapName().trim();
    const borderColor = newMapBorderColor().trim();
    const file = selectedFile();

    if (!name || !file) return;

    // Convert file to base64
    const reader = new FileReader();
    reader.onload = async (e) => {
      const imageData = e.target?.result as string;
      await mapsStore.addMap(name, imageData, borderColor || undefined);
      setNewMapName("");
      setNewMapBorderColor("");
      setSelectedFile(null);
      setSelectedFileName("");
    };
    reader.readAsDataURL(file);
  };

  // Save landmark (new or edit)
  const saveLandmark = () => {
    const name = editName().trim();
    const description = editDescription().trim();

    if (!name || isSaving()) return; // Only name is required and prevent double-clicks
    
    // Validate population if provided
    if (editPopulation().trim() && !validatePopulation(editPopulation())) {
      setPopulationError("Please enter a valid number");
      return;
    }
    
    setIsSaving(true);
    
    try {
      if (isAddingNew() && mapsStore.selectedMap) {
        // Remember the settings for next time
        setLastUsedColor(editColor());
        setLastUsedSize(editSize());
        setLastUsedType(editType());
        localStorage.setItem('lastLandmarkColor', editColor());
        localStorage.setItem('lastLandmarkSize', editSize());
        localStorage.setItem('lastLandmarkType', editType());
        
        // Add new landmark
        mapsStore.addLandmark(
          mapsStore.selectedMap.id,
          {
            x: newLandmarkPos().x,
            y: newLandmarkPos().y,
            name,
            description,
            type: editType(),
            population: editPopulation() || undefined,
            industry: (editIndustry() as LandmarkIndustry) || undefined,
            planetaryBodies: editPlanetaryBodies() || undefined,
            color: editColor(),
            size: editSize(),
          },
        );
        // The reactive effect will handle adding the sprite and updating the overlay
        // So we don't need to do it manually here
      } else if (selectedLandmark() && mapsStore.selectedMap) {
        // Update existing landmark
        mapsStore.updateLandmark(
          mapsStore.selectedMap.id,
          selectedLandmark()!.id,
          {
            name,
            description,
            type: editType(),
            population: editPopulation() || undefined,
            industry: (editIndustry() as LandmarkIndustry) || undefined,
            planetaryBodies: editPlanetaryBodies() || undefined,
            color: editColor(),
            size: editSize(),
          },
        );
        // The reactive effect will handle refreshing landmarks and updating the overlay
        // So we don't need to do it manually here
      }

      setIsEditing(false);
      setIsAddingNew(false);
      setSelectedLandmark(null);
    } finally {
      // Reset saving state after a short delay to provide UI feedback
      setTimeout(() => setIsSaving(false), 200);
    }
  };

  // Delete landmark
  const deleteLandmark = () => {
    if (selectedLandmark() && mapsStore.selectedMap && !isDeleting()) {
      setIsDeleting(true);
      
      try {
        mapsStore.deleteLandmark(
          mapsStore.selectedMap.id,
          selectedLandmark()!.id,
        );
        setSelectedLandmark(null);

        // Refresh all landmarks after delete
        if (landmarkContainer && mapsStore.selectedMap) {
          landmarkContainer.removeChildren();
          if (labelContainer) {
            labelContainer.removeChildren();
          }
          mapsStore.selectedMap.landmarks.forEach((landmark) => {
            addLandmarkSprite(landmark);
          });
          // Update Voronoi overlay
          updateVoronoiOverlay();
        }
      } finally {
        // Reset deleting state after a short delay to provide UI feedback
        setTimeout(() => setIsDeleting(false), 200);
      }
    }
  };
  
  // Calculate safe popup position that stays within viewport
  const calculateSafePopupPosition = (x: number, y: number, preferVertical: boolean = false, actualHeight?: number) => {
    const popupWidth = 280; // Fixed width from CSS
    const popupHeight = actualHeight || 400; // Use actual height if available, else max from CSS
    const padding = 10; // Minimum distance from viewport edges
    
    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    let finalX = x;
    let finalY = y;
    
    if (preferVertical) {
      // Mobile: Always stick to top of viewport
      
      // Center horizontally on the point
      finalX = x - popupWidth / 2;
      
      // Always position at top
      finalY = padding;
      
      // Ensure X stays within bounds (centered but adjusted if needed)
      if (finalX < padding) {
        finalX = padding;
      } else if (finalX + popupWidth + padding > viewportWidth) {
        finalX = viewportWidth - popupWidth - padding;
      }
    } else {
      // Desktop: Prioritize horizontal positioning (left/right)
      
      // Calculate initial position (offset to the right)
      finalX = x + 80;
      finalY = y - 10;
      
      // Adjust X position if popup would go off right edge
      if (finalX + popupWidth + padding > viewportWidth) {
        // Try positioning to the left of the point instead
        finalX = x - popupWidth - 20;
        // If still off screen, just position at right edge
        if (finalX < padding) {
          finalX = viewportWidth - popupWidth - padding;
        }
      }
      
      // Ensure X doesn't go off left edge
      if (finalX < padding) {
        finalX = padding;
      }
      
      // Adjust Y position if popup would go off bottom edge
      if (finalY + popupHeight + padding > viewportHeight) {
        // Try positioning above the point instead
        finalY = y - popupHeight - 20;
        // If still off screen, just position at bottom edge
        if (finalY < padding) {
          finalY = viewportHeight - popupHeight - padding;
        }
      }
      
      // Ensure Y doesn't go off top edge
      if (finalY < padding) {
        finalY = padding;
      }
    }
    
    return { x: finalX, y: finalY };
  };

  // Focus on a landmark from the list
  const focusOnLandmark = (landmark: Landmark) => {
    if (!viewport || !mapSprite) return;

    // Set as selected
    setSelectedLandmark(landmark);
    setIsEditing(false);
    setIsAddingNew(false);

    // Calculate world position from normalized coordinates
    const worldX = landmark.x * mapSprite.width;
    const worldY = landmark.y * mapSprite.height;

    // Move to the landmark position
    // Check if animate method exists (it's available in pixi-viewport)
    const vp = viewport as any;
    if (vp.animate) {
      vp.animate({
        position: { x: worldX, y: worldY },
        scale: Math.max(1, viewport.scale.x), // Ensure minimum zoom level
        time: 500, // Animation duration in ms
        ease: "easeInOutSine",
      });
    } else {
      // Fallback to immediate positioning
      vp.moveCenter(worldX, worldY);
    }

    // Show the landmark popup
    const screenPos = viewport.toScreen(worldX, worldY);
    const baseX = screenPos.x + (canvasContainer?.offsetLeft || 0);
    const baseY = screenPos.y + (canvasContainer?.offsetTop || 0);
    const isMobile = window.innerWidth < 768;
    setPopupPosition(calculateSafePopupPosition(baseX, baseY, isMobile));
  };

  // Start editing existing landmark
  const startEditing = () => {
    if (selectedLandmark()) {
      setEditName(selectedLandmark()!.name);
      setEditDescription(selectedLandmark()!.description);
      setEditType(selectedLandmark()!.type || "system");
      setEditPopulation(selectedLandmark()!.population || "");
      setEditIndustry(selectedLandmark()!.industry || "");
      setEditPlanetaryBodies(selectedLandmark()!.planetaryBodies || "");
      setPopulationError("");
      setEditColor(selectedLandmark()!.color || "#3498db");
      setEditSize(selectedLandmark()!.size || "medium");
      setIsEditing(true);
      setIsAddingNew(false);
    }
  };
  
  // Load allegiance when landmark is selected or states change
  createEffect(() => {
    const landmark = selectedLandmark();
    const map = mapsStore.selectedMap;
    const messageId = currentMessageId();
    // Track accumulated states changes
    landmarkStatesStore.accumulatedStates;
    
    if (landmark && map) {
      // Get the current allegiance (accumulated up to this point)
      const allegiance = landmarkStatesStore.getLandmarkState(
        map.id,
        landmark.id,
        'allegiance'
      );
      setSelectedAllegiance(allegiance);
      
      // Find where the current allegiance was set
      const key = `${map.id}:${landmark.id}:allegiance`;
      const accumulatedState = landmarkStatesStore.accumulatedStates[key];
      setAllegianceSourceMessageId(accumulatedState?.messageId || null);
      
      // Check if there's a state change at THIS specific message
      if (messageId) {
        const stateAtThisMessage = landmarkStatesStore.states.find(
          s => s.mapId === map.id && 
               s.landmarkId === landmark.id && 
               s.messageId === messageId && 
               s.field === 'allegiance'
        );
        setAllegianceAtThisMessage(stateAtThisMessage?.value || null);
      } else {
        setAllegianceAtThisMessage(null);
      }
    } else {
      setSelectedAllegiance(null);
      setAllegianceAtThisMessage(null);
      setAllegianceSourceMessageId(null);
    }
  });
  
  // Save allegiance for selected landmark
  const saveAllegiance = async (value: string | null) => {
    const landmark = selectedLandmark();
    const map = mapsStore.selectedMap;
    const messageId = currentMessageId();
    const storyId = currentStoryStore.id;
    
    if (!landmark || !map || !messageId || !storyId) return;
    
    setIsSavingAllegiance(true);
    console.log('Saving allegiance:', { storyId, mapId: map.id, landmarkId: landmark.id, messageId, value });
    try {
      await landmarkStatesStore.setLandmarkState(
        storyId,
        map.id,
        landmark.id,
        messageId,
        'allegiance',
        value
      );
      console.log('Allegiance saved successfully');
      
      // If we deleted (value is null), we need to check what the accumulated state is now
      if (value === null) {
        // Force reload accumulated states to get the correct inherited value
        await landmarkStatesStore.loadAccumulatedStates(storyId, messageId);
        
        // After reloading, get the new accumulated value (might be inherited from earlier)
        const newAllegiance = landmarkStatesStore.getLandmarkState(
          map.id,
          landmark.id,
          'allegiance'
        );
        setSelectedAllegiance(newAllegiance);
        setAllegianceAtThisMessage(null); // No state at this message anymore
      } else {
        // We set a new value
        setSelectedAllegiance(value);
        setAllegianceAtThisMessage(value);
      }
      
      // Force re-render of this specific landmark
      if (landmarkContainer && mapSprite) {
        // Find and remove the existing sprite
        const existingSprites = landmarkContainer.children as LandmarkSprite[];
        const existingSprite = existingSprites.find(s => s.landmarkData?.id === landmark.id);
        
        if (existingSprite) {
          landmarkContainer.removeChild(existingSprite);
          if (existingSprite.labelText && labelContainer) {
            labelContainer.removeChild(existingSprite.labelText);
          }
          
          // Re-add the sprite with updated border color
          addLandmarkSprite(landmark);
        }
      }
      
      // Also update Voronoi overlay if it's visible
      if (showFactionOverlay()) {
        updateVoronoiOverlay();
      }
    } catch (error) {
      console.error('Failed to save allegiance:', error);
    } finally {
      setIsSavingAllegiance(false);
    }
  };

  // Cancel editing
  const cancelEditing = () => {
    setIsEditing(false);
    setIsAddingNew(false);
    if (isAddingNew()) {
      setSelectedLandmark(null);
    }
  };

  // Fetch landmark info from web search
  const fetchLandmarkInfo = async () => {
    const name = editName().trim();
    const type = editType();
    if (!name || isFetchingLandmarkInfo()) return;
    
    // Only proceed if fields are empty
    const hasExistingInfo = editPopulation() || editIndustry() || editDescription() || editPlanetaryBodies();
    if (hasExistingInfo && !confirm('This will overwrite existing information. Continue?')) {
      return;
    }
    
    setIsFetchingLandmarkInfo(true);
    
    try {
      const info = await searchLandmarkInfo(name, type);
      
      // Only update empty fields by default, unless user confirmed overwrite
      if (!editPopulation() || hasExistingInfo) {
        setEditPopulation(info.population || editPopulation());
      }
      if (!editIndustry() || hasExistingInfo) {
        setEditIndustry(info.industry || editIndustry());
      }
      if (!editDescription() || hasExistingInfo) {
        setEditDescription(info.description || editDescription());
      }
      if (!editPlanetaryBodies() || hasExistingInfo) {
        setEditPlanetaryBodies(info.planetaryBodies || editPlanetaryBodies());
      }
      
      console.log('Fetched landmark info:', info);
    } catch (error) {
      console.error('Failed to fetch landmark info:', error);
      alert('Failed to fetch landmark information. Please check your Anthropic API key and try again.');
    } finally {
      setIsFetchingLandmarkInfo(false);
    }
  };

  // Load accumulated landmark states when timeline changes
  createEffect(() => {
    const messageId = currentMessageId();
    const storyId = currentStoryStore.id;
    
    if (messageId && storyId) {
      // Just load the states, the main reactive effect will handle re-rendering
      landmarkStatesStore.loadAccumulatedStates(storyId, messageId);
    }
  });
  
  // Initialize Pixi when canvas container is available and map is selected
  createEffect(() => {
    if (canvasContainer && mapsStore.selectedMap && !pixiApp) {
      initializePixi();
    }
  });

  // Handle map selection change
  createEffect(() => {
    const map = mapsStore.selectedMap;
    if (map && map.imageData && pixiApp) {
      loadMap(map.imageData);
    }
  });

  // Handle resize
  const handleResize = () => {
    if (pixiApp && canvasContainer && viewport) {
      pixiApp.renderer.resize(
        canvasContainer.clientWidth,
        canvasContainer.clientHeight,
      );
      viewport.resize(
        canvasContainer.clientWidth,
        canvasContainer.clientHeight,
      );
    }
  };

  onMount(() => {
    window.addEventListener("resize", handleResize);
  });

  onCleanup(() => {
    window.removeEventListener("resize", handleResize);
    if (pixiApp) {
      pixiApp.destroy(true);
      pixiApp = null;
    }
    // Clean up timeline debounce timer
    if (timelineDebounceTimer !== null) {
      clearTimeout(timelineDebounceTimer);
    }
    // Cancel any progressive rendering
    if (distanceFieldAnimationId) {
      cancelAnimationFrame(distanceFieldAnimationId);
      distanceFieldAnimationId = null;
    }
  });

  return (
    <Show when={mapsStore.showMaps}>
      <div class={styles.mapsPanel}>
        <MapControls
          showAddMap={showAddMap}
          setShowAddMap={setShowAddMap}
          newMapName={newMapName}
          setNewMapName={setNewMapName}
          newMapBorderColor={newMapBorderColor}
          setNewMapBorderColor={setNewMapBorderColor}
          selectedFileName={selectedFileName}
          editingBorderColor={editingBorderColor}
          setEditingBorderColor={setEditingBorderColor}
          editBorderColorValue={editBorderColorValue}
          setEditBorderColorValue={setEditBorderColorValue}
          onFileSelect={handleFileSelect}
          onAddMap={handleAddMap}
        />

        <MapTimeline
          assistantMessages={assistantMessages}
          timelineMessageInfo={timelineMessageInfo}
          pendingTimelinePosition={pendingTimelinePosition}
          handleTimelineChange={handleTimelineChange}
          stepTimeline={stepTimeline}
          onReset={() => {
            // Cancel any pending update
            if (timelineDebounceTimer !== null) {
              clearTimeout(timelineDebounceTimer);
              timelineDebounceTimer = null;
            }
            setPendingTimelinePosition(null);
            mapsStore.resetTimelinePosition();
          }}
        />

        <div class={styles.mapViewer}>
          <div class={styles.mapContainer}>
            <Show when={!mapsStore.selectedMap}>
              <div class={styles.noMapMessage}>
                Select a map or add a new one to get started
              </div>
            </Show>
            <div
              ref={canvasContainer}
              class={styles.mapCanvas}
              style={{ display: mapsStore.selectedMap ? "block" : "none" }}
            ></div>
            <FactionOverlayControls
              showFactionOverlay={showFactionOverlay}
              setShowFactionOverlay={setShowFactionOverlay}
              overlayMethod={overlayMethod}
              setOverlayMethod={setOverlayMethod}
            />
          </div>

          <LandmarksList
            sortedLandmarks={sortedLandmarks}
            selectedLandmark={selectedLandmark}
            sortAscending={sortAscending}
            setSortAscending={setSortAscending}
            onFocusLandmark={focusOnLandmark}
          />
        </div>

        {/* Landmark popup */}
        <Show when={selectedLandmark() || isAddingNew()}>
          <div
            ref={popupElement}
            class={styles.landmarkPopup}
            style={{
              left: `${popupPosition().x}px`,
              top: `${popupPosition().y}px`,
            }}
          >
            <div class={styles.landmarkPopupContent}>
              <Show
                when={isEditing()}
                fallback={
                  <>
                    <Show when={selectedLandmark()}>
                      <div class={styles.landmarkName}>
                        <EJSRenderer template={selectedLandmark()!.name} mode="inline" />
                      </div>
                      <div class={styles.landmarkDescription}>
                        <EJSRenderer
                          template={selectedLandmark()!.description}
                          mode="inline"
                        />
                      </div>
                      
                      {/* Population and Industry info */}
                      <Show when={selectedLandmark()!.population || selectedLandmark()!.industry}>
                        <div class={styles.landmarkDetails}>
                          <Show when={selectedLandmark()!.population}>
                            <div class={styles.landmarkDetailRow}>
                              <span class={styles.landmarkDetailLabel}>Population:</span>
                              <span class={styles.landmarkDetailValue}>
                                {(() => {
                                  const pop = selectedLandmark()!.population;
                                  // Try to format if it's a valid number
                                  const parsed = parsePopulation(pop || "");
                                  return parsed !== null ? formatPopulation(parsed) : pop;
                                })()}
                              </span>
                            </div>
                          </Show>
                          <Show when={selectedLandmark()!.industry}>
                            <div class={styles.landmarkDetailRow}>
                              <span class={styles.landmarkDetailLabel}>Industry:</span>
                              <span class={styles.landmarkDetailValue}>
                                {selectedLandmark()!.industry!.charAt(0).toUpperCase() + selectedLandmark()!.industry!.slice(1)}
                              </span>
                            </div>
                          </Show>
                          <Show when={selectedLandmark()!.planetaryBodies}>
                            <div class={styles.landmarkDetailRow}>
                              <span class={styles.landmarkDetailLabel}>Planetary Bodies:</span>
                              <span class={styles.landmarkDetailValue}>
                                {selectedLandmark()!.planetaryBodies}
                              </span>
                            </div>
                          </Show>
                        </div>
                      </Show>
                      
                      {/* Allegiance selector */}
                      <Show when={currentMessageId()}>
                        <div class={styles.allegianceSection}>
                          <div class={styles.allegianceHeader}>
                            <div class={styles.allegianceLabel}>
                              Allegiance at this point:
                            </div>
                            <Show when={allegianceSourceMessageId() && allegianceSourceMessageId() !== currentMessageId()}>
                              <button
                                class={styles.jumpButton}
                                onClick={() => jumpToMessage(allegianceSourceMessageId()!)}
                                title="Jump to where this allegiance was set"
                              >
                                <BsArrowReturnLeft /> Jump to source
                              </button>
                            </Show>
                          </div>
                          <div class={styles.allegianceButtons}>
                            <For each={LANDMARK_STATE_FIELDS.allegiance.values}>
                              {(option) => {
                                const isSelected = selectedAllegiance() === option.value;
                                const isSetHere = allegianceAtThisMessage() === option.value;
                                const isInherited = isSelected && !isSetHere;
                                
                                return (
                                  <button
                                    class={`${styles.allegianceButton} ${
                                      isSelected ? styles.selected : ''
                                    } ${isInherited ? styles.inherited : ''}`}
                                    style={{
                                      'background-color': isSelected 
                                        ? option.color 
                                        : 'transparent',
                                      'border-color': option.color,
                                      color: isSelected 
                                        ? '#fff' 
                                        : option.color,
                                      opacity: isInherited ? 0.7 : 1
                                    }}
                                    title={isInherited ? 'Inherited from earlier message' : ''}
                                    onClick={() => {
                                      // Only allow unselecting if there's a state at this specific message
                                      if (selectedAllegiance() === option.value && allegianceAtThisMessage() === option.value) {
                                        // Unselect - remove the state at this message
                                        saveAllegiance(null);
                                      } else if (selectedAllegiance() !== option.value) {
                                        // Select/change - set the state at this message
                                        saveAllegiance(option.value);
                                      }
                                      // If it's selected but not at this message, do nothing (can't unselect inherited state)
                                    }}
                                    disabled={isSavingAllegiance()}
                                  >
                                    {option.label}
                                  </button>
                                )
                              }}
                            </For>
                          </div>
                          <Show when={isSavingAllegiance()}>
                            <div class={styles.savingIndicator}>
                              <AiOutlineLoading3Quarters class="animate-spin" /> Saving...
                            </div>
                          </Show>
                        </div>
                      </Show>
                      
                      <div class={styles.landmarkActions}>
                        <button
                          class={styles.landmarkButton}
                          onClick={startEditing}
                        >
                          <BsPencil /> Edit
                        </button>
                        <button
                          class={`${styles.landmarkButton} ${styles.delete}`}
                          onClick={deleteLandmark}
                          disabled={isDeleting()}
                        >
                          <Show when={!isDeleting()} fallback={<><AiOutlineLoading3Quarters class="animate-spin" /> Deleting...</>}>
                            <BsTrash /> Delete
                          </Show>
                        </button>
                      </div>
                    </Show>
                  </>
                }
              >
                <div class={styles.landmarkEditForm}>
                  <input
                    type="text"
                    class={styles.landmarkInput}
                    value={editName()}
                    onInput={(e) => setEditName(e.target.value)}
                    placeholder="Landmark name"
                  />

                  <Show when={settingsStore.provider === 'anthropic' && editName().trim()}>
                    <button
                      type="button"
                      class={styles.fetchInfoButton}
                      onClick={fetchLandmarkInfo}
                      disabled={isFetchingLandmarkInfo()}
                      title="Search the web for information about this landmark"
                    >
                      <Show when={!isFetchingLandmarkInfo()} fallback={<><AiOutlineLoading3Quarters class="animate-spin" /> Searching...</>}>
                        <BsSearch /> Search for Info
                      </Show>
                    </button>
                  </Show>

                  <EJSCodeEditor
                    value={editDescription()}
                    onChange={setEditDescription}
                    placeholder="Landmark description (supports EJS templates)"
                    minHeight="80px"
                  />

                  <div class={styles.colorPicker}>
                    <div class={styles.colorPickerRow}>
                      <span class={styles.colorPickerLabel}>Pin color:</span>
                      <input
                        type="color"
                        class={styles.colorInput}
                        value={editColor()}
                        onInput={(e) => setEditColor(e.target.value)}
                      />
                    </div>
                    <div class={styles.colorQuickPicks}>
                      <For each={quickColors}>
                        {(color) => (
                          <button
                            type="button"
                            class={`${styles.colorQuickPick} ${editColor() === color.hex ? styles.selected : ""} ${color.name === "White" ? styles.white : ""}`}
                            style={{ background: color.hex }}
                            onClick={() => setEditColor(color.hex)}
                            title={color.name}
                          />
                        )}
                      </For>
                    </div>
                  </div>

                  <div class={styles.sizePicker}>
                    <span class={styles.sizePickerLabel}>Pin size:</span>
                    <div class={styles.sizeButtons}>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editSize() === "small" ? styles.selected : ""}`}
                        onClick={() => setEditSize("small")}
                      >
                        Small
                      </button>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editSize() === "medium" ? styles.selected : ""}`}
                        onClick={() => setEditSize("medium")}
                      >
                        Medium
                      </button>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editSize() === "large" ? styles.selected : ""}`}
                        onClick={() => setEditSize("large")}
                      >
                        Large
                      </button>
                    </div>
                  </div>

                  <div class={styles.sizePicker}>
                    <span class={styles.sizePickerLabel}>Type:</span>
                    <div class={styles.sizeButtons}>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editType() === "system" ? styles.selected : ""}`}
                        onClick={() => setEditType("system")}
                      >
                        System
                      </button>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editType() === "station" ? styles.selected : ""}`}
                        onClick={() => setEditType("station")}
                      >
                        Station
                      </button>
                      <button
                        type="button"
                        class={`${styles.sizeButton} ${editType() === "nebula" ? styles.selected : ""}`}
                        onClick={() => setEditType("nebula")}
                      >
                        Nebula
                      </button>
                    </div>
                  </div>

                  <div class={styles.landmarkFormGroup}>
                    <label>Population</label>
                    <input
                      type="text"
                      class={`${styles.landmarkInput} ${populationError() ? styles.inputError : ''}`}
                      value={editPopulation()}
                      onInput={(e) => handlePopulationInput(e.currentTarget.value)}
                      onBlur={(e) => {
                        // Format on blur if valid
                        const value = e.currentTarget.value;
                        if (validatePopulation(value)) {
                          const parsed = parsePopulation(value);
                          if (parsed !== null) {
                            setEditPopulation(formatPopulation(parsed));
                          }
                        }
                      }}
                      placeholder="e.g., 1,500,000"
                    />
                    <Show when={populationError()}>
                      <span class={styles.errorMessage}>{populationError()}</span>
                    </Show>
                  </div>

                  <div class={styles.landmarkFormGroup}>
                    <label>Primary Industry</label>
                    <select
                      class={styles.landmarkSelect}
                      value={editIndustry()}
                      onChange={(e) => setEditIndustry(e.currentTarget.value as LandmarkIndustry | "")}
                    >
                      <option value="">None</option>
                      <option value="farming">Farming</option>
                      <option value="political">Political</option>
                      <option value="industry">Industry</option>
                      <option value="trade">Trade</option>
                      <option value="mining">Mining</option>
                    </select>
                  </div>

                  <Show when={editType() === 'system'}>
                    <div class={styles.landmarkFormRow}>
                      <label class={styles.landmarkFormLabel}>Planetary Bodies:</label>
                      <input
                        type="text"
                        class={styles.landmarkInput}
                        value={editPlanetaryBodies()}
                        onInput={(e) => setEditPlanetaryBodies(e.target.value)}
                        placeholder="e.g., Planet Name I, Planet Name II, Moon Name"
                      />
                      <span class={styles.landmarkFormHint}>Comma-separated list of planets and moons in the system</span>
                    </div>
                  </Show>

                  <div class={styles.landmarkFormActions}>
                    <button
                      class={styles.landmarkSaveButton}
                      onClick={saveLandmark}
                      disabled={!editName().trim() || isSaving()}
                    >
                      <Show when={!isSaving()} fallback={<><AiOutlineLoading3Quarters class="animate-spin" /> Saving...</>}>
                        <BsCheck /> Save
                      </Show>
                    </button>
                    <button
                      class={styles.landmarkCancelButton}
                      onClick={cancelEditing}
                    >
                      <BsX /> Cancel
                    </button>
                  </div>
                </div>
              </Show>
            </div>
          </div>
        </Show>
      </div>
    </Show>
  );
};
