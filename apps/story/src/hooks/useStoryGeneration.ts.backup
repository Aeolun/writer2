import { Message } from "../types/core";
import { messagesStore } from "../stores/messagesStore";
import { settingsStore } from "../stores/settingsStore";
import { charactersStore } from "../stores/charactersStore";
import { contextItemsStore } from "../stores/contextItemsStore";
import { currentStoryStore } from "../stores/currentStoryStore";
import { chaptersStore } from "../stores/chaptersStore";
import { generateContextMessages } from "../utils/contextGeneration";
import { analyzeStoryBeat, extractKnownEntities } from "../utils/smartContext";
import { generateAnalysis } from "../utils/analysisClient";
import { generateNextStoryBeatInstructions } from "../utils/autoGeneration";
import { generateMessageId } from "../utils/id";
import {
    getTemplatedCharacterContext,
    getTemplatedContextItems,
} from "../utils/contextTemplating";

interface UseStoryGenerationProps {
    generateResponse: (
        messages: any[],
        assistantMessageId: string,
        shouldSummarize: boolean,
        maxTokens?: number,
    ) => Promise<void>;
    generateSummary: (content: string) => Promise<string>;
    generateParagraphSummary: (content: string) => Promise<string>;
    generateCompactionSummary: (contents: string[]) => Promise<string>;
}

export const useStoryGeneration = (props: UseStoryGenerationProps) => {
    // Flag to prevent multiple simultaneous regenerations
    let regenerateInProgress = false;

    // Helper function to generate messages with context
    const generateMessagesWithContext = async (
        inputText: string,
        messages: Message[],
        targetMessageId: string,
        forceMissingSummaries = false,
    ) => {
        // Generate templated context based on the target message
        const characterContext = getTemplatedCharacterContext(
            charactersStore.characters,
            messages,
            targetMessageId,
            currentStoryStore.globalScript,
        );
        const contextItemsContext = getTemplatedContextItems(
            contextItemsStore.contextItems,
            messages,
            targetMessageId,
            currentStoryStore.globalScript,
        );
        const fullContext = characterContext + contextItemsContext;

        // For protagonist name, we need the evaluated version
        const evaluatedCharacters = charactersStore.characters;
        const protagonistName = evaluatedCharacters.find(
            (c) => c.isProtagonist,
        )?.name;

        return generateContextMessages({
            inputText,
            messages,
            contextType: settingsStore.useSmartContext ? 'smart-story' : 'story',
            storySetting: currentStoryStore.storySetting,
            person: currentStoryStore.person,
            tense: currentStoryStore.tense,
            protagonistName,
            paragraphsPerTurn: settingsStore.paragraphsPerTurn,
            characterContext: fullContext,
            characters: charactersStore.characters,
            contextItems: contextItemsStore.contextItems,
            chapters: chaptersStore.state.chapters,
            targetMessageId,
            model: settingsStore.model,
            provider: settingsStore.provider as "ollama" | "openrouter" | "anthropic",
            forceMissingSummaries,
        });
    };

    const handleAutoOrManualSubmit = async (
        isQuery = false,
        maxTokens?: number,
    ) => {
        if (
            settingsStore.autoGenerate &&
            !messagesStore.input.trim() &&
            !isQuery
        ) {
            try {
                console.log("Generating auto-instructions for manual start...");
                const autoInstructions =
                    await generateNextStoryBeatInstructions(
                        generateAnalysis,
                        settingsStore.paragraphsPerTurn,
                    );
                console.log("Generated auto-instructions:", autoInstructions);

                messagesStore.setInput(autoInstructions);
                await handleSubmit(false, maxTokens, true);
            } catch (error) {
                console.error("Failed to generate auto-instructions:", error);
            }
        } else {
            await handleSubmit(isQuery, maxTokens, true);
        }
    };

    const handleSubmit = async (
        isQuery = false,
        maxTokens?: number,
        clearInputAfter = true,
    ) => {
        const inputText = messagesStore.input.trim();
        if (!inputText || messagesStore.isLoading || !settingsStore.model)
            return;

        messagesStore.setIsLoading(true);

        if (isQuery) {
            const assistantMessageId = generateMessageId();
            const selectedChapterId = chaptersStore.getSelectedChapterId();
            const assistantMessage: Message = {
                id: assistantMessageId,
                role: "assistant",
                content: "",
                instruction: inputText,
                timestamp: new Date(),
                order: 0,  // Will be set properly by insertMessage/addMessage
                isQuery: true,
                model: settingsStore.model,
                chapterId: selectedChapterId || messagesStore.getCurrentChapterId(),
            };
            
            // Insert query at the end of selected chapter, just like story messages
            if (selectedChapterId) {
                const insertAfterId = messagesStore.getInsertAfterIdForChapter(selectedChapterId);
                if (insertAfterId) {
                    messagesStore.insertMessage(insertAfterId, assistantMessage);
                } else {
                    // Fallback: add to end if we can't find the chapter
                    console.warn(`Could not find insertion point for chapter ${selectedChapterId}`);
                    messagesStore.addMessage(assistantMessage);
                }
            } else {
                // No chapter selected, add to end as usual
                messagesStore.addMessage(assistantMessage);
            }

            try {
                // Get messages up to where we just inserted the query
                let messagesForContext: Message[];
                if (selectedChapterId) {
                    const insertedMessageIndex = messagesStore.messages.findIndex(m => m.id === assistantMessageId);
                    if (insertedMessageIndex !== -1) {
                        messagesForContext = messagesStore.messages.slice(0, insertedMessageIndex + 1);
                    } else {
                        messagesForContext = messagesStore.visibleMessages;
                    }
                } else {
                    messagesForContext = messagesStore.visibleMessages;
                }
                
                // Use messages up to insertion point for script execution
                const characterContext = getTemplatedCharacterContext(
                    charactersStore.characters,
                    messagesForContext,
                    assistantMessageId,
                    currentStoryStore.globalScript,
                );
                const contextItemsContext = getTemplatedContextItems(
                    contextItemsStore.contextItems,
                    messagesForContext,
                    assistantMessageId,
                    currentStoryStore.globalScript,
                );
                const queryMessages = await generateContextMessages({
                    inputText,
                    messages: messagesForContext,
                    contextType: 'query',
                    characterContext: characterContext + contextItemsContext,
                    model: settingsStore.model,
                    chapters: chaptersStore.state.chapters,
                    targetMessageId: assistantMessageId,
                    includeQueryHistory: true,
                    maxQueryHistory: 5,
                });

                await props.generateResponse(
                    queryMessages,
                    assistantMessageId,
                    false,
                    maxTokens,
                );
            } catch (error) {
                console.error("Query generation failed:", error);
                messagesStore.clearAssistantContent(assistantMessageId);
            }
        } else {
            const assistantMessageId = generateMessageId();
            const selectedChapterId = chaptersStore.getSelectedChapterId();
            const assistantMessage: Message = {
                id: assistantMessageId,
                role: "assistant",
                content: "",
                instruction: inputText,
                timestamp: new Date(),
                order: 0,  // Will be set properly by insertMessage/addMessage
                isQuery: false,
                model: settingsStore.model,
                chapterId: selectedChapterId || messagesStore.getCurrentChapterId(),
            };
            
            // If a chapter is selected, insert at the end of that chapter
            if (selectedChapterId) {
                const insertAfterId = messagesStore.getInsertAfterIdForChapter(selectedChapterId);
                if (insertAfterId) {
                    messagesStore.insertMessage(insertAfterId, assistantMessage);
                } else {
                    // Fallback: add to end if we can't find the chapter
                    console.warn(`Could not find insertion point for chapter ${selectedChapterId}`);
                    messagesStore.addMessage(assistantMessage);
                }
            } else {
                // No chapter selected, add to end as usual
                messagesStore.addMessage(assistantMessage);
            }

            try {
                // Get messages up to where we just inserted the new message
                let messagesForContext: Message[];
                if (selectedChapterId) {
                    // We just inserted at the end of the selected chapter
                    const insertedMessageIndex = messagesStore.messages.findIndex(m => m.id === assistantMessageId);
                    if (insertedMessageIndex !== -1) {
                        messagesForContext = messagesStore.messages.slice(0, insertedMessageIndex + 1).filter(m => !m.isQuery);
                    } else {
                        // Fallback
                        messagesForContext = messagesStore.visibleMessages.filter(m => !m.isQuery);
                    }
                } else {
                    // No chapter selected, message was added at the end
                    messagesForContext = messagesStore.visibleMessages.filter(m => !m.isQuery);
                }
                
                const messages = await generateMessagesWithContext(
                    inputText,
                    messagesForContext,
                    assistantMessageId,
                );
                await props.generateResponse(
                    messages,
                    assistantMessageId,
                    true,
                    maxTokens,
                );
            } catch (error: any) {
                console.error("Story generation failed:", error);
                
                // Handle missing chapter summaries with a confirmation dialog
                if (error.message && error.message.includes("previous chapters need summaries")) {
                    const proceed = confirm(
                        error.message + "\n\nDo you want to continue anyway? The story might lack important context from previous chapters."
                    );
                    
                    if (proceed) {
                        try {
                            // Generate with forceMissingSummaries flag
                            const messages = await generateMessagesWithContext(
                                inputText,
                                messagesStore.visibleMessages.filter((m) => !m.isQuery),
                                assistantMessageId,
                                true, // forceMissingSummaries flag
                            );
                            await props.generateResponse(
                                messages,
                                assistantMessageId,
                                true,
                                maxTokens,
                            );
                        } catch (retryError) {
                            console.error("Story generation failed on retry:", retryError);
                            messagesStore.clearAssistantContent(assistantMessageId);
                            alert("Failed to generate story. Please try again.");
                        }
                    } else {
                        messagesStore.clearAssistantContent(assistantMessageId);
                    }
                } else {
                    messagesStore.clearAssistantContent(assistantMessageId);
                    alert("Failed to generate story. Please try again.");
                }
            }
        }

        if (clearInputAfter) {
            messagesStore.clearInput();
        }
        messagesStore.setIsLoading(false);
    };

    const regenerateLastMessage = async (maxTokens?: number) => {
        console.log("regenerateLastMessage called with maxTokens:", maxTokens);

        if (regenerateInProgress) {
            console.warn("Regeneration already in progress, skipping");
            return;
        }

        if (messagesStore.isLoading) {
            console.warn("Already loading, skipping regenerate");
            return;
        }

        const messages = messagesStore.messages;
        const lastMessage = messages[messages.length - 1];
        if (!lastMessage || !lastMessage.instruction) {
            console.warn("No last message or instruction to regenerate");
            return;
        }

        try {
            regenerateInProgress = true;
            console.log("Regenerating message:", lastMessage.id);
            const instruction = lastMessage.instruction;
            const isQuery = lastMessage.isQuery || false;

            // Import batch from solid-js to batch updates
            const { batch } = await import("solid-js");

            // Batch all store updates together to prevent multiple reactive updates
            batch(() => {
                // Delete the message first
                messagesStore.deleteMessage(lastMessage.id);

                // Set the input after deletion
                messagesStore.setInput(instruction);
            });

            // Submit the regeneration after the batch completes
            await handleSubmit(isQuery, maxTokens, false);
        } finally {
            regenerateInProgress = false;
        }
    };

    const handleRegenerateFromMessage = async (
        messageId: string,
        content: string,
        maxTokens?: number,
    ) => {
        const message = messagesStore.messages.find((m) => m.id === messageId);
        if (!message) return;

        messagesStore.setIsLoading(true);
        messagesStore.updateMessage(messageId, { content: "" });

        try {
            // Find the index of the message being regenerated
            const messageIndex = messagesStore.messages.findIndex((m) => m.id === messageId);
            if (messageIndex === -1) throw new Error("Message not found");
            
            // Include messages up to and including the one being regenerated
            // The regenerated message should have empty content at this point
            const messagesUpToTarget = messagesStore.messages.slice(0, messageIndex + 1);
            const messages = await generateMessagesWithContext(
                content,
                messagesUpToTarget.filter((m) => !m.isQuery),
                messageId,
            );

            // Regenerate the response for this specific message
            await props.generateResponse(
                messages,
                messageId,
                !message.isQuery,
                maxTokens,
            );
        } catch (error: any) {
            console.error("Regeneration failed:", error);
            
            // Handle missing chapter summaries with a confirmation dialog
            if (error.message && error.message.includes("previous chapters need summaries")) {
                const proceed = confirm(
                    error.message + "\n\nDo you want to continue anyway? The story might lack important context from previous chapters."
                );
                
                if (proceed) {
                    try {
                        // Find the index of the message being regenerated
                        const messageIndex = messagesStore.messages.findIndex((m) => m.id === messageId);
                        if (messageIndex === -1) throw new Error("Message not found");
                        
                        // Include messages up to and including the one being regenerated
                        const messagesUpToTarget = messagesStore.messages.slice(0, messageIndex + 1);
                        const messages = await generateMessagesWithContext(
                            content,
                            messagesUpToTarget.filter((m) => !m.isQuery),
                            messageId,
                            true, // forceMissingSummaries flag
                        );

                        // Regenerate the response for this specific message
                        await props.generateResponse(
                            messages,
                            messageId,
                            !message.isQuery,
                            maxTokens,
                        );
                    } catch (retryError) {
                        console.error("Regeneration failed on retry:", retryError);
                        alert("Failed to regenerate message. Please try again.");
                    }
                }
            } else {
                alert("Failed to regenerate message. Please try again.");
            }
        }

        messagesStore.setIsLoading(false);
    };

    const handleRegenerateQuery = async (
        messageId: string,
        queryText: string,
        maxTokens?: number,
    ) => {
        const message = messagesStore.messages.find((m) => m.id === messageId);
        if (!message || !message.isQuery) return;

        messagesStore.setIsLoading(true);
        messagesStore.updateMessage(messageId, { content: "" });

        try {
            // Find the index of the query being regenerated
            const messageIndex = messagesStore.messages.findIndex((m) => m.id === messageId);
            if (messageIndex === -1) throw new Error("Query message not found");
            
            // For queries, we need messages up to this query to include previous Q&As
            const messagesUpToTarget = messagesStore.messages.slice(0, messageIndex + 1);
            const allMessages = messagesUpToTarget;
            // But for character/context templating, we only use story messages
            const storyMessages = allMessages.filter(
                (m) => !m.isQuery && m.role === "assistant",
            );
            const characterContext = getTemplatedCharacterContext(
                charactersStore.characters,
                storyMessages,
                messageId,
                currentStoryStore.globalScript,
            );
            const contextItemsContext = getTemplatedContextItems(
                contextItemsStore.contextItems,
                storyMessages,
                messageId,
                currentStoryStore.globalScript,
            );
            const queryMessages = await generateContextMessages({
                inputText: queryText,
                messages: allMessages,
                contextType: 'query',
                characterContext: characterContext + contextItemsContext,
                model: settingsStore.model,
                chapters: chaptersStore.state.chapters,
                targetMessageId: messageId,
                includeQueryHistory: true,
                maxQueryHistory: 5,
            });

            await props.generateResponse(
                queryMessages,
                messageId,
                false,
                maxTokens,
            );
        } catch (error) {
            console.error("Query regeneration failed:", error);
        }

        messagesStore.setIsLoading(false);
    };

    const handleSummarizeMessage = async (
        messageId: string,
        generateParagraph = false,
    ) => {
        const message = messagesStore.messages.find((m) => m.id === messageId);
        if (!message) return;

        messagesStore.setSummarizing(messageId, true);

        try {
            const summary = generateParagraph
                ? await props.generateParagraphSummary(message.content)
                : await props.generateSummary(message.content);

            if (generateParagraph) {
                messagesStore.updateMessage(messageId, {
                    paragraphSummary: summary,
                });
            } else {
                messagesStore.updateMessage(messageId, { summary });
            }
        } catch (error) {
            console.error("Summarization failed:", error);
        }

        messagesStore.setSummarizing(messageId, false);
    };

    const handleAnalyzeMessage = async (messageId: string) => {
        const message = messagesStore.messages.find((m) => m.id === messageId);
        if (!message) return;

        messagesStore.setAnalyzing(messageId, true);

        try {
            const entities = extractKnownEntities(
                charactersStore.characters,
                contextItemsStore.contextItems,
            );

            const analysis = await analyzeStoryBeat(
                message,
                entities,
                generateAnalysis,
            );

            messagesStore.updateMessage(messageId, { sceneAnalysis: analysis });

            // TODO: Add smartEntityDetection to settingsStore if needed
            // if (settingsStore.smartEntityDetection) {
            //   const newEntities = await detectNewEntities(
            //     message.content,
            //     entities.knownCharacters,
            //     entities.knownLocations,
            //     entities.knownThemes,
            //     generateAnalysis
            //   )
            //
            //   if ((newEntities.characters.length > 0 || newEntities.locations.length > 0 || newEntities.themes.length > 0)) {
            //     const descriptions = await generateEntityDescriptions(
            //       newEntities,
            //       messagesStore.getStoryContext(),
            //       generateAnalysis
            //     )
            //
            //     addDiscoveredEntitiesToStores(newEntities, descriptions)
            //   }
            // }
        } catch (error) {
            console.error("Analysis failed:", error);
        }

        messagesStore.setAnalyzing(messageId, false);
    };

    const handleCompactMessages = async (messageIds: string[]) => {
        try {
            messagesStore.setIsLoading(true);

            const messagesToCompact = messagesStore.messages
                .filter((m) => messageIds.includes(m.id))
                .map((m) => m.content);

            const compactedContent =
                await props.generateCompactionSummary(messagesToCompact);

            // Use the store's method which keeps the original messages but hides them
            messagesStore.createCompactedMessage(messageIds, compactedContent);

            // Trigger save immediately after compaction to prevent data loss
            messagesStore.saveManually();
        } catch (error) {
            console.error("Failed to compact messages:", error);
        } finally {
            messagesStore.setIsLoading(false);
        }
    };

    const handleShowContextPreview = async () => {
        const inputText = messagesStore.input.trim() || "[Empty input]";

        try {
            const selectedChapterId = chaptersStore.getSelectedChapterId();
            const visibleMessages = messagesStore.getVisibleMessages();
            
            // Create a preview message ID with the selected chapter
            const previewMessageId = generateMessageId();
            
            // Create a temporary message object to simulate what would be generated
            // This allows generateMessagesWithContext to properly determine chapter context
            const previewMessage: Message = {
                id: previewMessageId,
                role: "assistant",
                content: "",
                instruction: inputText,
                timestamp: new Date(),
                isQuery: false,
                model: settingsStore.model,
                chapterId: selectedChapterId || messagesStore.getCurrentChapterId(),
            };
            
            // Only include messages up to the selected chapter for proper script context
            let messagesUpToChapter: Message[];
            const targetChapterId = selectedChapterId || messagesStore.getCurrentChapterId();
            
            if (targetChapterId) {
                // Find where the new message would be inserted
                const insertAfterId = messagesStore.getInsertAfterIdForChapter(targetChapterId);
                if (insertAfterId) {
                    // Find the index of this message
                    const insertAfterIndex = visibleMessages.findIndex(m => m.id === insertAfterId);
                    if (insertAfterIndex !== -1) {
                        // Include all messages up to and including the insertion point
                        messagesUpToChapter = visibleMessages.slice(0, insertAfterIndex + 1).filter(m => !m.isQuery);
                    } else {
                        // Fallback to all messages if we can't find the insertion point
                        messagesUpToChapter = visibleMessages.filter(m => !m.isQuery);
                    }
                } else {
                    // No insertion point found, use all messages
                    messagesUpToChapter = visibleMessages.filter(m => !m.isQuery);
                }
            } else {
                // No chapter selected, use all messages
                messagesUpToChapter = visibleMessages.filter(m => !m.isQuery);
            }
            
            const allMessagesWithPreview = [...messagesUpToChapter, previewMessage];
            
            const messages = await generateMessagesWithContext(
                inputText,
                allMessagesWithPreview,
                previewMessageId,
            );
            
            // Filter out any message that might contain our preview instruction
            const filteredMessages = messages.filter(msg => 
                !(msg.role === 'user' && msg.content === inputText)
            );

            return {
                type: settingsStore.useSmartContext
                    ? "Smart Context"
                    : "Full History",
                messages: filteredMessages.map((msg) => ({
                    role: msg.role,
                    content: msg.content,
                    cache_control: msg.cache_control,
                })),
            };
        } catch (error) {
            console.error("Failed to generate context preview:", error);
            return null;
        }
    };

    return {
        generateMessagesWithContext,
        handleAutoOrManualSubmit,
        handleSubmit,
        regenerateLastMessage,
        handleRegenerateFromMessage,
        handleRegenerateQuery,
        handleSummarizeMessage,
        handleAnalyzeMessage,
        handleCompactMessages,
        handleShowContextPreview,
    };
};
