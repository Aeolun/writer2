import { Component, createEffect, Show, createSignal, onCleanup, createMemo } from 'solid-js'
import './styles/variables.css'
import './App.css'
import styles from './App.module.css'
import { Message, Character, Chapter, ContextItem } from './types/core'
import { ApiStory } from './types/api'
import { useOllama } from './hooks/useOllama'
import { useStoryGeneration } from './hooks/useStoryGeneration'
import { useCacheManagement } from './hooks/useCacheManagement'
import { MessageList } from './components/MessageList'
import { GlobalStatusIndicator } from './components/GlobalStatusIndicator'
import { PendingEntitiesModal } from './components/PendingEntitiesModal'
import { CostStatusIndicator } from './components/CostStatusIndicator'
import { CompactionDialog } from './components/CompactionDialog'
import { StorageFullModal } from './components/StorageFullModal'
import { StorageMigrationBanner } from './components/StorageMigrationBanner'
import { ConflictResolutionDialog } from './components/ConflictResolutionDialog'
import { StoryInput } from './components/StoryInput'
import { StoryHeader } from './components/StoryHeader'
import { ContextPreviewModal } from './components/ContextPreviewModal'
import { StoryLandingPage } from './components/StoryLandingPage'
import { MessageRewriter } from './components/MessageRewriter'
import { ErrorNotifications } from './components/ErrorNotifications'
import { messagesStore } from './stores/messagesStore'
import { settingsStore } from './stores/settingsStore'
import { modelsStore } from './stores/modelsStore'
import { charactersStore } from './stores/charactersStore'
import { chaptersStore } from './stores/chaptersStore'
import { contextItemsStore } from './stores/contextItemsStore'
import { globalOperationStore } from './stores/globalOperationStore'
import { storyManager } from './utils/storyManager'
import { currentStoryStore } from './stores/currentStoryStore'

const App: Component = () => {
  const { generateResponse, generateSummary, generateParagraphSummary, generateCompactionSummary, generateChapterSummary, abortGeneration, isGenerating, checkIfOllamaIsBusy } = useOllama()
  
  const [showCompactionDialog, setShowCompactionDialog] = createSignal(false)
  const [showContextPreview, setShowContextPreview] = createSignal(false)
  const [showMessageRewriter, setShowMessageRewriter] = createSignal(false)
  const [preselectedMessageId, setPreselectedMessageId] = createSignal<string | null>(null)
  const [contextPreviewData, setContextPreviewData] = createSignal<{type: string, messages: Array<{role: 'system' | 'user' | 'assistant', content: string, cache_control?: {type: 'ephemeral', ttl?: '5m' | '1h'}}> } | null>(null)
  const [ollamaExternallyBusy, setOllamaExternallyBusy] = createSignal(false)
  const [serverDataConflict, setServerDataConflict] = createSignal<{serverStory: ApiStory, localMessages: Message[]} | null>(null)

  // Check if story is initialized
  const storyLoaded = createMemo(() => currentStoryStore.isInitialized)

  // Initialize story generation hook
  const {
    handleAutoOrManualSubmit,
    handleSubmit,
    regenerateLastMessage,
    handleRegenerateFromMessage,
    handleRegenerateQuery,
    handleSummarizeMessage,
    handleAnalyzeMessage,
    handleCompactMessages,
    handleShowContextPreview
  } = useStoryGeneration({
    generateResponse,
    generateSummary,
    generateParagraphSummary,
    generateCompactionSummary
  })

  // Initialize cache management
  useCacheManagement()

  // Effective context size based on model and provider
  const effectiveContextSize = createMemo(() => {
    const selectedModel = modelsStore.availableModels.find(m => m.name === settingsStore.model)
    
    // For Anthropic and OpenRouter, always use the model's full context length
    if (settingsStore.provider === 'anthropic' || settingsStore.provider === 'openrouter') {
      if (selectedModel?.context_length) {
        return selectedModel.context_length
      }
    }
    
    // For Ollama, use the minimum of user setting and model's context length
    if (selectedModel?.context_length) {
      return Math.min(settingsStore.contextSize, selectedModel.context_length)
    }
    return settingsStore.contextSize
  })

  // Initialize messagesStore effects for localStorage persistence
  messagesStore.initializeEffects()

  // Clean up old settings
  localStorage.removeItem('story-ollama-host')
  localStorage.removeItem('story-current') // No longer using localStorage for current story

  // Fetch models on initialization and when provider changes
  createEffect(() => {
    // Access provider to make this effect reactive to provider changes
    settingsStore.provider
    modelsStore.fetchModels()
  })
  
  // Helper function to load server story data
  const loadServerStoryData = async (serverStory: ApiStory, storyId: string) => {
    const { currentStoryStore } = await import('./stores/currentStoryStore')
    currentStoryStore.loadStory(
      storyId,
      serverStory.name,
      'server',
      serverStory.person || 'third',
      serverStory.tense || 'past',
      serverStory.storySetting || '',
      serverStory.globalScript
    )
    currentStoryStore.setLastKnownUpdatedAt(serverStory.updatedAt)
    // Load the story data
    handleLoadStory(
      serverStory.messages,
      serverStory.characters || [],
      serverStory.input || '',
      serverStory.storySetting || '',
      serverStory.chapters || [],
      serverStory.selectedChapterId,
      serverStory.contextItems || []
    )
    
    // Clean up any local duplicate
    const localStory = await storyManager.loadStory(storyId)
    if (localStory) {
      console.log('Cleaning up local duplicate of server story:', storyId)
      await storyManager.deleteStory(storyId)
    }
  }

  // Load story from URL hash if present
  const loadStoryFromHash = async () => {
    const hash = window.location.hash.slice(1)
    if (hash.startsWith('story=')) {
      const storyId = hash.substring(6)
      console.log('Loading story from hash:', storyId)
      
      // Check if this is an old ID format (timestamp-based)
      // Matches patterns like: 1754232850821-w2kv7u3vl or 1754232438376-pm7i6zrj2
      if (/^\d{13}-\w+$/.test(storyId)) {
        console.warn('Detected old story ID format, clearing hash and reloading')
        window.location.hash = ''
        window.location.reload()
        return
      }
      
      // Try server first (server stories take priority)
      try {
        const { apiClient } = await import('./utils/apiClient')
        const serverStory = await apiClient.getStory(storyId)
        if (serverStory) {
          console.log('Found server story:', serverStory.name)
          
          // Check if we have local messages that might conflict
          const currentMessages = messagesStore.messages
          if (currentMessages.length > 0) {
            // Create a set of server message IDs for quick lookup
            const serverMessageIds = new Set(serverStory.messages.map((m: Message) => m.id))
            
            // Check if client has any messages not on the server
            const clientOnlyMessages = currentMessages.filter(m => !serverMessageIds.has(m.id))
            
            if (clientOnlyMessages.length > 0) {
              // Client has messages that don't exist on server - need confirmation
              console.log(`Client has ${clientOnlyMessages.length} messages not on server, showing conflict dialog`)
              setServerDataConflict({ serverStory, localMessages: currentMessages })
              return
            }
          }
          
          // Safe to load - either no local messages or all local messages exist on server
          await loadServerStoryData(serverStory, storyId)
          return
        }
      } catch (error) {
        console.log('Story not found on server, checking local storage')
      }
      
      // If not on server, try local storage
      const story = await storyManager.loadStory(storyId)
      if (story) {
        console.log('Found local story:', story.name)
        // Update currentStoryStore
        const { currentStoryStore } = await import('./stores/currentStoryStore')
        currentStoryStore.loadStory(
          story.id,
          story.name,
          story.storageMode || 'local',
          story.person,
          story.tense,
          story.storySetting,
          story.globalScript
        )
        // Load the story data
        handleLoadStory(story.messages, story.characters, story.input, story.storySetting, story.chapters, story.selectedChapterId, story.contextItems)
      }
    }
  }
  
  // Load story on mount
  loadStoryFromHash()

  // Run story migration on startup
  createEffect(() => {
    storyManager.migrateStories().catch(error => {
      console.error('Failed to migrate stories:', error)
    })
  })

  // Auto-generation setup
  createEffect(() => {
    const handleAutoGenerate = async (event: Event) => {
      const customEvent = event as CustomEvent
      const instructions = customEvent.detail?.instructions || ''
      
      console.log('Auto-generate event received with instructions:', instructions)
      messagesStore.setInput(instructions)
      
      await handleSubmit(false)
    }

    window.addEventListener('auto-generate-story', handleAutoGenerate as unknown as EventListener)
    
    onCleanup(() => {
      window.removeEventListener('auto-generate-story', handleAutoGenerate as unknown as EventListener)
    })
  })

  // Periodically check if Ollama is busy
  createEffect(() => {
    if (settingsStore.provider === 'ollama') {
      let checkInterval: NodeJS.Timeout
      const checkBusy = async () => {
        const isBusy = await checkIfOllamaIsBusy()
        setOllamaExternallyBusy(isBusy)
      }

      checkBusy()
      checkInterval = setInterval(checkBusy, 5000)

      onCleanup(() => {
        clearInterval(checkInterval)
      })
    } else {
      setOllamaExternallyBusy(false)
    }
  })

  const handleShowContextPreviewModal = async () => {
    const data = await handleShowContextPreview()
    if (data) {
      setContextPreviewData(data)
      setShowContextPreview(true)
    }
  }

  const handleUpdateMessage = (id: string, content: string, instruction?: string) => {
    const updates: Partial<Message> = {}
    if (instruction !== undefined) {
      updates.instruction = instruction
    } else {
      updates.content = content
    }
    messagesStore.updateMessage(id, updates)
  }

  const handleBulkSummarize = async () => {
    if (!confirm('This will generate summaries for all messages. Continue?')) return

    const messages = messagesStore.messages.filter(m => m.role === 'assistant' && !m.isQuery && !m.summary)
    globalOperationStore.startOperation('bulk-summarize', messages.length, 'Generating summaries...')

    try {
      for (let i = 0; i < messages.length; i++) {
        const message = messages[i]
        globalOperationStore.updateProgress(i + 1, `Summarizing message ${i + 1} of ${messages.length}`)
        await handleSummarizeMessage(message.id, false)
      }
    } finally {
      globalOperationStore.completeOperation()
    }
  }

  const handleBulkAnalysis = async () => {
    if (!confirm('This will analyze all story messages for scene context. Continue?')) return

    messagesStore.setIsAnalyzing(true)
    
    try {
      const storyMessages = messagesStore.messages.filter(m => m.role === 'assistant' && !m.isQuery && !m.sceneAnalysis)
      
      for (const message of storyMessages) {
        await handleAnalyzeMessage(message.id)
      }
    } finally {
      messagesStore.setIsAnalyzing(false)
    }
  }

  const handleMigrateInstructions = () => {
    if (!confirm('This will update all messages to use the new instruction format. Continue?')) return
    // TODO: Implement migrateToInstructionFormat in messagesStore
    console.error('migrateToInstructionFormat not implemented')
  }

  const handleRemoveUserMessages = () => {
    if (!confirm('This will remove all user messages from the story. This action cannot be undone. Continue?')) return
    // TODO: Implement removeUserMessages in messagesStore
    console.error('removeUserMessages not implemented')
  }

  const handleCleanupThinkTags = () => {
    if (!confirm('This will remove all <think> tags from the story content. Continue?')) return
    messagesStore.cleanupThinkTags()
  }
  
  const handleRewriteMessages = (messageId?: string) => {
    setPreselectedMessageId(messageId || null)
    setShowMessageRewriter(true)
  }

  const handleExportStory = () => {
    const storyMessages = messagesStore.messages.filter(m => m.role === 'assistant' && !m.isQuery)
    const chapters = storyMessages.map((msg, index) => {
      const chapterHeader = `--- Chapter ${index + 1} ---\n\n`
      return chapterHeader + msg.content
    })
    
    const storyContent = chapters.join('\n\n\n')
    const blob = new Blob([storyContent], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = 'story-export.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  const handleImportStory = () => {
    const input = document.createElement('input')
    input.type = 'file'
    input.accept = '.txt,.json'
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0]
      if (!file) return
      
      const text = await file.text()
      await importStoryFromText(text)
    }
    input.click()
  }

  const importStoryFromText = async (importText: string) => {
    try {
      const importData = JSON.parse(importText)
      
      if (Array.isArray(importData.messages)) {
        messagesStore.clearMessages()
        
        importData.messages.forEach((msg: Message) => {
          const message: Message = {
            ...msg,
            timestamp: new Date(msg.timestamp),
            isSummarizing: false
          }
          messagesStore.addMessage(message)
        })
        
        if (importData.characters) {
          charactersStore.setCharacters(importData.characters)
        }
        
        if (importData.contextItems) {
          contextItemsStore.setContextItems(importData.contextItems)
        }
        
        if (importData.settings) {
          if (importData.settings.storySetting) {
            settingsStore.setStorySetting(importData.settings.storySetting)
          }
          if (importData.settings.provider) {
            settingsStore.setProvider(importData.settings.provider)
          }
          if (importData.settings.model) {
            settingsStore.setModel(importData.settings.model)
          }
        }
        
        if (importData.currentInput) {
          messagesStore.setInput(importData.currentInput)
        }
        
        console.log(`Story imported from JSON: ${importData.messages.length} messages`)
        return
      }
    } catch (jsonError) {
      console.log('JSON import failed, trying text import:', jsonError)
    }
    
    messagesStore.clearMessages()
    
    const chapters = importText
      .split(/--- Chapter \d+ ---|\n\n\n/)
      .map(chapter => chapter.trim())
      .filter(chapter => chapter.length > 0)

    const { generateMessageId } = await import('./utils/id')
    
    chapters.forEach((chapter, index) => {
      const message: Message = {
        id: generateMessageId(),
        role: 'assistant',
        content: chapter,
        instruction: index === 0 ? 'Begin the story' : 'Continue the story',
        timestamp: new Date(Date.now() + index * 1000),
        isQuery: false
      }
      messagesStore.addMessage(message)
    })

    console.log(`Story imported from text: ${chapters.length} chapters`)
  }

  const handleLoadStory = (messages: Message[], characters: Character[], input: string, storySetting: string, chapters?: Chapter[], selectedChapterId?: string | null, contextItems?: ContextItem[]) => {
    console.log(`handleLoadStory called with ${messages.length} messages, ${characters.length} characters, ${chapters?.length || 0} chapters, selectedChapterId: ${selectedChapterId}, ${contextItems?.length || 0} contextItems`)
    
    // Ensure timestamps are Date objects
    let messagesWithDates = messages.map(msg => ({
      ...msg,
      timestamp: msg.timestamp instanceof Date ? msg.timestamp : new Date(msg.timestamp)
    }))
    
    // Handle chapters
    if (chapters && chapters.length > 0) {
      // Create a map of chapter IDs to chapters for quick lookup
      const chapterMap = new Map(chapters.map(ch => [ch.id, ch]))
      
      // Sync chapter summaries to chapter marker messages
      messagesWithDates = messagesWithDates.map(msg => {
        if (msg.type === 'chapter' && msg.chapterId && chapterMap.has(msg.chapterId)) {
          const chapter = chapterMap.get(msg.chapterId)!
          return {
            ...msg,
            summary: chapter.summary // Add the chapter summary to the marker message
          }
        }
        return msg
      })
      
      // Use the proper loadChapters method which handles Date conversion and logging
      // Pass messages so it can restore summaries from chapter markers if needed
      chaptersStore.loadChapters(chapters, messagesWithDates, selectedChapterId)
    } else {
      // Reconstruct chapters from messages for backward compatibility
      chaptersStore.reconstructChapterAssociations(messagesWithDates)
    }
    
    messagesStore.setMessages(messagesWithDates)
    charactersStore.setCharacters(characters)
    messagesStore.setInput(input)
    settingsStore.setStorySetting(storySetting)
    
    // Load context items if provided
    if (contextItems) {
      contextItemsStore.setContextItems(contextItems)
    }
    
    console.log(`Story loaded successfully`)
  }

  return (
    <Show 
      when={storyLoaded()} 
      fallback={<StoryLandingPage onStoryLoaded={() => window.location.reload()} />}
    >
      <div class={styles.app}>
        <StorageMigrationBanner />
        <GlobalStatusIndicator />
      
      <StoryHeader
        onShowCompactionDialog={() => setShowCompactionDialog(true)}
        onLoadStory={handleLoadStory}
        onBulkSummarize={handleBulkSummarize}
        onBulkAnalysis={handleBulkAnalysis}
        onMigrateInstructions={handleMigrateInstructions}
        onRemoveUserMessages={handleRemoveUserMessages}
        onCleanupThinkTags={handleCleanupThinkTags}
        onRewriteMessages={handleRewriteMessages}
        onExportStory={handleExportStory}
        onImportStory={handleImportStory}
        isGenerating={isGenerating() || ollamaExternallyBusy()}
        contextSize={effectiveContextSize()}
        charsPerToken={settingsStore.charsPerToken}
      />

      <main class={styles.chatContainer}>
        <MessageList
          messages={messagesStore.visibleMessages}
          contextSize={effectiveContextSize()}
          charsPerToken={settingsStore.charsPerToken}
          isLoading={messagesStore.isLoading}
          hasStoryMessages={messagesStore.hasStoryMessages}
          onDeleteMessage={messagesStore.deleteMessage}
          onUpdateMessage={handleUpdateMessage}
          onRegenerateFromMessage={handleRegenerateFromMessage}
          onRegenerateQuery={handleRegenerateQuery}
          onSummarizeMessage={handleSummarizeMessage}
          onAnalyzeMessage={handleAnalyzeMessage}
          onRewriteMessage={(messageId: string) => handleRewriteMessages(messageId)}
          onGenerateChapterSummary={generateChapterSummary}
          isGenerating={isGenerating() || ollamaExternallyBusy()}
          model={settingsStore.model}
          provider={settingsStore.provider as 'ollama' | 'openrouter' | 'anthropic'}
        />

        <Show when={settingsStore.provider === 'anthropic' || settingsStore.provider === 'openrouter' || settingsStore.provider === 'openai'}>
          <CostStatusIndicator isGenerating={isGenerating()} />
        </Show>

        <StoryInput
          isLoading={messagesStore.isLoading}
          isAnalyzing={messagesStore.isAnalyzing}
          isGenerating={isGenerating() || ollamaExternallyBusy()}
          onSubmit={handleSubmit}
          onAutoOrManualSubmit={handleAutoOrManualSubmit}
          onRegenerate={regenerateLastMessage}
          onAbort={abortGeneration}
          onShowContextPreview={handleShowContextPreviewModal}
        />
      </main>

      <ContextPreviewModal
        show={showContextPreview()}
        data={contextPreviewData()}
        onClose={() => setShowContextPreview(false)}
      />

      <PendingEntitiesModal />
      
      <CompactionDialog 
        show={showCompactionDialog()}
        onClose={() => setShowCompactionDialog(false)}
        onCompact={handleCompactMessages}
      />
      
      <Show when={showMessageRewriter()}>
        <MessageRewriter
          messages={messagesStore.messages.filter(m => m.role === 'assistant' && !m.isQuery)}
          preselectedMessageId={preselectedMessageId()}
          onClose={() => {
            setShowMessageRewriter(false)
            setPreselectedMessageId(null)
          }}
        />
      </Show>
      
      <StorageFullModal
        isOpen={messagesStore.showStorageFullModal}
        onClose={() => messagesStore.setShowStorageFullModal(false)}
      />
      
      <ConflictResolutionDialog
        isOpen={messagesStore.showConflictDialog}
        serverUpdatedAt={messagesStore.conflictInfo?.serverUpdatedAt || ''}
        clientUpdatedAt={messagesStore.conflictInfo?.clientUpdatedAt || ''}
        onForce={() => messagesStore.forceSave()}
        onCancel={() => messagesStore.setShowConflictDialog(false)}
      />
      
      <Show when={serverDataConflict()}>
        <div class="modal-overlay" onClick={(e) => e.stopPropagation()}>
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h3>Local Changes Detected</h3>
            </div>
            <div class="modal-body">
              <p style="margin-bottom: 1rem;">
                You have local messages that don't exist on the server. Loading the server version will lose these changes.
              </p>
              <p style="margin-bottom: 1rem;">
                <strong>Server story:</strong> {serverDataConflict()!.serverStory.messages.length} messages<br/>
                <strong>Local story:</strong> {serverDataConflict()!.localMessages.length} messages
              </p>
              <p style="margin-bottom: 1.5rem;">
                Do you want to load the server version and lose your local changes?
              </p>
              <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button 
                  class="secondary-button"
                  onClick={() => {
                    // Keep local version
                    setServerDataConflict(null)
                    // Clear the hash to prevent reload conflicts
                    window.location.hash = ''
                  }}
                >
                  Keep Local Version
                </button>
                <button 
                  class="primary-button"
                  onClick={async () => {
                    const conflict = serverDataConflict()
                    if (conflict) {
                      await loadServerStoryData(conflict.serverStory, conflict.serverStory.id)
                      setServerDataConflict(null)
                    }
                  }}
                >
                  Load Server Version
                </button>
              </div>
            </div>
          </div>
        </div>
      </Show>
      
      <ErrorNotifications />
      </div>
    </Show>
  )
}

export default App